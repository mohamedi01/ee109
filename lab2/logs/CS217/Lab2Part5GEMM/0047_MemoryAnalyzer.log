---------------------------------------------------------------------
INFERRING...
Name: x762
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x762 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x793 {0} [x800 (stage: -1)]
  1 Read Groups:
  Group #0
    x793 = RegRead(x762) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x785 {} [x787 (stage: -1)]
  1 Write Groups:
  Group #0
    x785 = RegWrite(x762,x773,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x793 {0}: 
      x785 {}
    x793 <-> x785: LCA: x801 (stage: -1), coarse-dist: <None>
    x785 <-> x785: LCA: x787 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x793 = RegRead(x762) rd{0}
   c  modrd -> x800
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: ListBuffer(b405)
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: List(0)
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: List(0)
  General read dephasing rules for x762: (b405,List(0)) -> (b405,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x793 = RegRead(x762) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x785: RegWrite
    x800: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x793: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x762
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x793 = RegRead(x762) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x785 = RegWrite(x762,x773,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x785 = RegWrite(x762,x773,Set()) {}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x787 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x793 = RegRead(x762) {0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x800 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x762
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x762 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x785 = RegWrite(x762,x773,Set()) {}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x787 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x793 = RegRead(x762) {0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x800 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x793 {0}
  Added dispatch 0 to x793 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x785 {}
  Added dispatch 0 to x785 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x793 {0}
  Added dispatch 0 to x793 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x785 {}
  Added dispatch 0 to x785 {}
---------------------------------------------------------------------
INFERRING...
Name: x683
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x683 = StreamInNew(BurstDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x732 {0,0} [x734 (stage: -1)]
  1 Read Groups:
  Group #0
    x732 = StreamInRead(x683,Set()) rd{0,0}
     b495  b352     c   mod
        1     1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x732 {0,0}: 
  Dephasing Iters: x732 = StreamInRead(x683,Set()) rd{0,0}
 b495  b352     c   mod
    1     1     0     0rd -> x734
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: ListBuffer(b495, b352)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  General read dephasing rules for x683: (b495,List(0, 0)) -> (b495,0)
  - (b352,List(0, 0)) -> (b352,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x732 = StreamInRead(x683,Set()) rd{0,0}
 b495  b352     c   mod
    1     1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
    x732: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x683
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x732 = StreamInRead(x683,Set()) rd{0,0}
      grp 0:  b495  b352     c   mod
      grp 0:     1     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x732 = StreamInRead(x683,Set()) {0,0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x683
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x683 = StreamInNew(BurstDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x732 = StreamInRead(x683,Set()) {0,0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x732 {0,0}
  Added dispatch 0 to x732 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x732 {0,0}
  Added dispatch 0 to x732 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x655
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x655 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x669 {0} [x677 (stage: -1)]
  1 Read Groups:
  Group #0
    x669 = RegRead(x655) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x660 {} [x665 (stage: -1)]
  1 Write Groups:
  Group #0
    x660 = RegWrite(x655,x659,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x669 {0}: 
      x660 {}
    x669 <-> x660: LCA: x678 (stage: -1), coarse-dist: <None>
    x660 <-> x660: LCA: x665 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x669 = RegRead(x655) rd{0}
   c  modrd -> x677
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: ListBuffer(b289)
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: List(0)
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: List(0)
  General read dephasing rules for x655: (b289,List(0)) -> (b289,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x669 = RegRead(x655) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x678: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x665: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x660: RegWrite
    x677: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x669: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x655
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x669 = RegRead(x655) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x660 = RegWrite(x655,x659,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x660 = RegWrite(x655,x659,Set()) {}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x665 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x669 = RegRead(x655) {0}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x677 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x655
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x655 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x660 = RegWrite(x655,x659,Set()) {}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x665 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x669 = RegRead(x655) {0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x677 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x669 {0}
  Added dispatch 0 to x669 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x660 {}
  Added dispatch 0 to x660 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x669 {0}
  Added dispatch 0 to x669 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x660 {}
  Added dispatch 0 to x660 {}
---------------------------------------------------------------------
INFERRING...
Name: M (x504)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:12:18
Src:      val M = ArgIn[Int]
Symbol:     x504 = ArgInNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 4 Reads: 
    Access: x524 {} [Host]
    Access: x530 {} [Host]
    Access: x545 {} [x808 (stage: -1)]
    Access: x549 {0,0} [x553 (stage: -1)]
  4 Read Groups:
  Group #0
    x524 = RegRead(x504) rd{}
       c  modrd
  Group #1
    x530 = RegRead(x504) rd{}
       c  modrd
  Group #2
    x545 = RegRead(x504) rd{}
       c  modrd
  Group #3
    x549 = RegRead(x504) rd{0,0}
       c  modrd
  Grouping 1 Writes: 
    Access: x509 {} [Host]
  1 Write Groups:
  Group #0
    x509 = SetReg(x504,x508) wr{}
       c  modwr



Merging memory instance groups:
Group #0: 
    x524 <-> x509: LCA: Host, coarse-dist: <None>
    x509 <-> x509: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x524 = RegRead(x504) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for M (x504)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x524 = RegRead(x504) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x509 = SetReg(x504,x508) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x524 = RegRead(x504) {}
      - Lab2GEMM.scala:23:21: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host))
  Result: Created instance #0
Group #1: 
    x530 <-> x509: LCA: Host, coarse-dist: <None>
    x509 <-> x509: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x530 = RegRead(x504) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for M (x504)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x530 = RegRead(x504) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x509 = SetReg(x504,x508) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x530 = RegRead(x504) {}
      - Lab2GEMM.scala:25:21: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x530 = Some(RegRead(x504)) - x524 = Some(RegRead(x504))
    Computing overlaps: x509 = Some(SetReg(x504,x508)) - x509 = Some(SetReg(x504,x508))
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x524 = RegRead(x504) rd{}
   c  modrd, x530 = RegRead(x504) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for M (x504)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
    ***** Cost summary *****
    Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 1: x530 = RegRead(x504) rd{}
        grp 1:    c  modrd
        grp 2: x524 = RegRead(x504) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x509 = SetReg(x504,x508) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x530 = RegRead(x504) {}
      - Lab2GEMM.scala:25:21: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host
  [Ofs: 0] x524 = RegRead(x504) {}
      - Lab2GEMM.scala:23:21: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host))
  Result: Merged 1 into instance 0
Group #2: 
    x545 <-> x509: LCA: Host, coarse-dist: <None>
    x509 <-> x509: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x545 = RegRead(x504) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for M (x504)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x545 = RegRead(x504) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x509 = SetReg(x504,x508) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x545 = RegRead(x504) {}
      - Lab2GEMM.scala:39:21: Foreach(M by tileM){mm =>
      - Scope: x808 (scope: -1, -1)))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x545 = Some(RegRead(x504)) - x524 = Some(RegRead(x504))
    Computing overlaps: x545 = Some(RegRead(x504)) - x530 = Some(RegRead(x504))
    Computing overlaps: x509 = Some(SetReg(x504,x508)) - x509 = Some(SetReg(x504,x508))
      x545 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
      x545 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x545 = RegRead(x504) rd{}
   c  modrd, x524 = RegRead(x504) rd{}
   c  modrd, x530 = RegRead(x504) rd{}
   c  modrd), Set(), Set(x524 = RegRead(x504) rd{}
   c  modrd, x530 = RegRead(x504) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for M (x504)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 5 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
    ***** Cost summary *****
    Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x545 = RegRead(x504) rd{}
        grp 0:    c  modrd
        grp 2: x524 = RegRead(x504) rd{}
        grp 2:    c  modrd
        grp 2: x530 = RegRead(x504) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x509 = SetReg(x504,x508) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x545 = RegRead(x504) {}
      - Lab2GEMM.scala:39:21: Foreach(M by tileM){mm =>
      - Scope: x808 (scope: -1, -1)
 - Mux Port #1: 
  [Ofs: 0] x530 = RegRead(x504) {}
      - Lab2GEMM.scala:25:21: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host
  [Ofs: 0] x524 = RegRead(x504) {}
      - Lab2GEMM.scala:23:21: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host))
  Result: Merged 2 into instance 0
Group #3: 
    x549 <-> x509: LCA: Host, coarse-dist: <None>
    x509 <-> x509: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x549 = RegRead(x504) rd{0,0}
   c  modrd -> x553
  Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: ListBuffer(b50, b57)
  Current: x553
  Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: List(0, 0)
  Current: x553
  Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: List(0, 0)
  Current: x553
  General read dephasing rules for x504: (b50,List(0, 0)) -> (b50,0)
  - (b57,List(0, 0)) -> (b57,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x549 = RegRead(x504) rd{0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for M (x504)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x549 = RegRead(x504) rd{0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x509 = SetReg(x504,x508) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x549 = RegRead(x504) {0,0}
      - Lab2GEMM.scala:40:50: val numel_m = min(tileM.to[Int], M - mm)
      - Scope: x553 (scope: 0, 0)))
  Attempting to merge group #3 with instance #0: 
    Computing overlaps: x549 = Some(RegRead(x504)) - x545 = Some(RegRead(x504))
    Computing overlaps: x549 = Some(RegRead(x504)) - x524 = Some(RegRead(x504))
    Computing overlaps: x549 = Some(RegRead(x504)) - x530 = Some(RegRead(x504))
    Computing overlaps: x549 = Some(RegRead(x504)) - x524 = Some(RegRead(x504))
    Computing overlaps: x549 = Some(RegRead(x504)) - x530 = Some(RegRead(x504))
    Computing overlaps: x509 = Some(SetReg(x504,x508)) - x509 = Some(SetReg(x504,x508))
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x545 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x549 <-> x509: LCA: Host, coarse-dist: <None>
      x530 <-> x509: LCA: Host, coarse-dist: <None>
      x545 <-> x509: LCA: Host, coarse-dist: <None>
      x509 <-> x509: LCA: Host, coarse-dist: <None>
      x524 <-> x509: LCA: Host, coarse-dist: <None>
      x549 <-> x509: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x549 = RegRead(x504) rd{0,0}
   c  modrd -> x553
    Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: ListBuffer(b50, b57)
    Current: x553
    Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: List(0, 0)
    Current: x553
    Leaf: x553, Iters: ListBuffer(b50, b57), target: x809, elements: List(0, 0)
    Current: x553
    General read dephasing rules for x504: (b50,List(0, 0)) -> (b50,0)
  - (b57,List(0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x549 = RegRead(x504) rd{0,0}
   c  modrd, x545 = RegRead(x504) rd{}
   c  modrd, x524 = RegRead(x504) rd{}
   c  modrd, x530 = RegRead(x504) rd{}
   c  modrd), Set(), Set(x524 = RegRead(x504) rd{}
   c  modrd, x530 = RegRead(x504) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for M (x504)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 6 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 4 | 1 |
            - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
    ***** Cost summary *****
    Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x549 = RegRead(x504) rd{0,0}
        grp 0:    c  modrd
        grp 2: x545 = RegRead(x504) rd{}
        grp 2:    c  modrd
        grp 2: x524 = RegRead(x504) rd{}
        grp 2:    c  modrd
        grp 2: x530 = RegRead(x504) rd{}
        grp 2:    c  modrd
        grp 3: x524 = RegRead(x504) rd{}
        grp 3:    c  modrd
        grp 3: x530 = RegRead(x504) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x509 = SetReg(x504,x508) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x509 = SetReg(x504,x508) {}
      - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x549 = RegRead(x504) {0,0}
      - Lab2GEMM.scala:40:50: val numel_m = min(tileM.to[Int], M - mm)
      - Scope: x553 (scope: 0, 0)
  [Ofs: 0] x545 = RegRead(x504) {}
      - Lab2GEMM.scala:39:21: Foreach(M by tileM){mm =>
      - Scope: x808 (scope: -1, -1)
 - Mux Port #1: 
  [Ofs: 0] x530 = RegRead(x504) {}
      - Lab2GEMM.scala:25:21: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host
  [Ofs: 0] x524 = RegRead(x504) {}
      - Lab2GEMM.scala:23:21: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host))
  Result: Merged 3 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: M (x504)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:12:18
Src:      val M = ArgIn[Int]
Symbol:     x504 = ArgInNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    Buffer
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x509 = SetReg(x504,x508) {}
        - Lab2GEMM.scala:15:11: setArg(M,args(0).to[Int])
        - Scope: Host
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x549 = RegRead(x504) {0,0}
        - Lab2GEMM.scala:40:50: val numel_m = min(tileM.to[Int], M - mm)
        - Scope: x553 (scope: 0, 0)
    [Ofs: 0] x545 = RegRead(x504) {}
        - Lab2GEMM.scala:39:21: Foreach(M by tileM){mm =>
        - Scope: x808 (scope: -1, -1)
   - Mux Port #1: 
    [Ofs: 0] x530 = RegRead(x504) {}
        - Lab2GEMM.scala:25:21: val c = DRAM[T](M, N) // an initial matrix for the result
        - Scope: Host
    [Ofs: 0] x524 = RegRead(x504) {}
        - Lab2GEMM.scala:23:21: val a = DRAM[T](M, K) // input matrix 1
        - Scope: Host



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x549 {0,0}
  Added dispatch 0 to x549 {0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x545 {}
  Added dispatch 0 to x545 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x524 {}
  Added dispatch 0 to x524 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x530 {}
  Added dispatch 0 to x530 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x524 {}
  Added dispatch 0 to x524 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x530 {}
  Added dispatch 0 to x530 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x509 {}
  Added dispatch 0 to x509 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x549 {0,0}
  Added dispatch 0 to x549 {0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x545 {}
  Added dispatch 0 to x545 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x524 {}
  Added dispatch 0 to x524 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x530 {}
  Added dispatch 0 to x530 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x524 {}
  Added dispatch 0 to x524 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x530 {}
  Added dispatch 0 to x530 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x509 {}
  Added dispatch 0 to x509 {}
---------------------------------------------------------------------
INFERRING...
Name: x587
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x587 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x601 {0} [x609 (stage: -1)]
  1 Read Groups:
  Group #0
    x601 = RegRead(x587) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x592 {} [x597 (stage: -1)]
  1 Write Groups:
  Group #0
    x592 = RegWrite(x587,x591,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x601 {0}: 
      x592 {}
    x601 <-> x592: LCA: x610 (stage: -1), coarse-dist: <None>
    x592 <-> x592: LCA: x597 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x601 = RegRead(x587) rd{0}
   c  modrd -> x609
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: ListBuffer(b223)
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: List(0)
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: List(0)
  General read dephasing rules for x587: (b223,List(0)) -> (b223,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x601 = RegRead(x587) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x610: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x597: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x592: RegWrite
    x609: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x601: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x587
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x601 = RegRead(x587) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x592 = RegWrite(x587,x591,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x592 = RegWrite(x587,x591,Set()) {}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x597 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x601 = RegRead(x587) {0}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x609 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x587
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x587 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x592 = RegWrite(x587,x591,Set()) {}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x597 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x601 = RegRead(x587) {0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x609 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x601 {0}
  Added dispatch 0 to x601 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x592 {}
  Added dispatch 0 to x592 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x601 {0}
  Added dispatch 0 to x601 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x592 {}
  Added dispatch 0 to x592 {}
---------------------------------------------------------------------
INFERRING...
Name: x756
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x756 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x783 {0} [x787 (stage: -1)]
  1 Write Groups:
  Group #0
    x783 = StreamOutWrite(x756,x781,Set(x782)) wr{0}
     b500     c   mod
        1     0     0wr
  x783 <-> x783: LCA: x787 (stage: -1), coarse-dist: <None>
Dephasing Iters: x783 = StreamOutWrite(x756,x781,Set(x782)) wr{0}
 b500     c   mod
    1     0     0wr -> x787
Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: ListBuffer(b500)
Current: x787
Current: x801
Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
Current: x787
Current: x801
Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
Current: x787
Current: x801
General write dephasing rules for x756: (b500,List(0)) -> (b500,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
  x783: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x756
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x783 = StreamOutWrite(x756,x781,Set(x782)) wr{0}
    grp 0:  b500     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x783 = StreamOutWrite(x756,x781,Set(x782)) {0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x787 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x756
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x756 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x783 = StreamOutWrite(x756,x781,Set(x782)) {0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x787 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x783 {0}
  Added dispatch 0 to x783 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x783 {0}
  Added dispatch 0 to x783 {0}
---------------------------------------------------------------------
INFERRING...
Name: x761
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x761 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x791 {0} [x800 (stage: -1)]
  1 Read Groups:
  Group #0
    x791 = RegRead(x761) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x784 {} [x787 (stage: -1)]
  1 Write Groups:
  Group #0
    x784 = RegWrite(x761,x771,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x791 {0}: 
      x784 {}
    x791 <-> x784: LCA: x801 (stage: -1), coarse-dist: <None>
    x784 <-> x784: LCA: x787 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x791 = RegRead(x761) rd{0}
   c  modrd -> x800
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: ListBuffer(b405)
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: List(0)
  Leaf: x800, Iters: ListBuffer(b405), target: x800, elements: List(0)
  General read dephasing rules for x761: (b405,List(0)) -> (b405,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x791 = RegRead(x761) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x784: RegWrite
    x800: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x791: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x761
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x791 = RegRead(x761) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x784 = RegWrite(x761,x771,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x784 = RegWrite(x761,x771,Set()) {}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x787 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x791 = RegRead(x761) {0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x800 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x761
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x761 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x784 = RegWrite(x761,x771,Set()) {}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x787 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x791 = RegRead(x761) {0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x800 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x791 {0}
  Added dispatch 0 to x791 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x784 {}
  Added dispatch 0 to x784 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x791 {0}
  Added dispatch 0 to x791 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x784 {}
  Added dispatch 0 to x784 {}
---------------------------------------------------------------------
INFERRING...
Name: x714
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x714 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x723 {} [x734 (stage: -1)]
  1 Read Groups:
  Group #0
    x723 = RegRead(x714) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x721 {} [x722 (stage: -1)]
  1 Write Groups:
  Group #0
    x721 = RegWrite(x714,x720,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x723 {}: 
      x721 {}
    x723 <-> x721: LCA: x735 (stage: -1), coarse-dist: <None>
    x721 <-> x721: LCA: x722 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x723 = RegRead(x714) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x735: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x722: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x721: RegWrite
    x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x723: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x714
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x723 = RegRead(x714) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x721 = RegWrite(x714,x720,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x721 = RegWrite(x714,x720,Set()) {}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x722 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x723 = RegRead(x714) {}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x714
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x714 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x721 = RegWrite(x714,x720,Set()) {}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x722 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x723 = RegRead(x714) {}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x723 {}
  Added dispatch 0 to x723 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x721 {}
  Added dispatch 0 to x721 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x723 {}
  Added dispatch 0 to x723 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x721 {}
  Added dispatch 0 to x721 {}
---------------------------------------------------------------------
INFERRING...
Name: x625
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x625 = FIFONew(Const(16))
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x658 {0} [x665 (stage: -1)]
  1 Read Groups:
  Group #0
    x658 = FIFODeq(x625,Set(Const(true))) rd{0}
     b486     c   mod
        1     0     0rd
  Grouping 1 Writes: 
    Access: x650 {0} [x651 (stage: -1)]
  1 Write Groups:
  Group #0
    x650 = FIFOEnq(x625,x649,Set(Const(true))) wr{0}
     b482     c   mod
        1     0     0wr



Merging memory instance groups:
Group #0: 
  Dephasing Iters: x658 = FIFODeq(x625,Set(Const(true))) rd{0}
 b486     c   mod
    1     0     0rd -> x665
  Leaf: x665, Iters: ListBuffer(b486), target: x678, elements: ListBuffer(b486)
  Current: x665
  Leaf: x665, Iters: ListBuffer(b486), target: x678, elements: List(0)
  Current: x665
  Leaf: x665, Iters: ListBuffer(b486), target: x678, elements: List(0)
  Current: x665
  General read dephasing rules for x625: (b486,List(0)) -> (b486,0)
  Dephasing Iters: x650 = FIFOEnq(x625,x649,Set(Const(true))) wr{0}
 b482     c   mod
    1     0     0wr -> x651
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
  General write dephasing rules for x625: (b482,List(0)) -> (b482,0)
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 3.605258356619518 (LUTs: 0.04678362573099415%, FFs: 0.0029191753329684362%, BRAMs: 3.5555555555555554%)
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x625
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x625 = FIFONew(Const(16))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x650 = FIFOEnq(x625,x649,Set(Const(true))) {0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x651 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x658 = FIFODeq(x625,Set(Const(true))) {0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x665 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x658 {0}
  Added dispatch 0 to x658 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x650 {0}
  Added dispatch 0 to x650 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x658 {0}
  Added dispatch 0 to x658 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x650 {0}
  Added dispatch 0 to x650 {0}
---------------------------------------------------------------------
INFERRING...
Name: x757
Type: StreamOut[Tup2[Fix[TRUE,_24,_8],Bit]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x757 = StreamOutNew(BurstFullDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x799 {0,0} [x800 (stage: -1)]
  1 Write Groups:
  Group #0
    x799 = StreamOutWrite(x757,x798,Set()) wr{0,0}
     b500  b405     c   mod
        1     1     0     0wr
  x799 <-> x799: LCA: x800 (stage: -1), coarse-dist: <None>
Dephasing Iters: x799 = StreamOutWrite(x757,x798,Set()) wr{0,0}
 b500  b405     c   mod
    1     1     0     0wr -> x800
Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: ListBuffer(b500, b405)
Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: List(0, 0)
Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: List(0, 0)
General write dephasing rules for x757: (b500,List(0, 0)) -> (b500,0)
  - (b405,List(0, 0)) -> (b405,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x800: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
  x799: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x757
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x799 = StreamOutWrite(x757,x798,Set()) wr{0,0}
    grp 0:  b500  b405     c   mod
    grp 0:     1     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x799 = StreamOutWrite(x757,x798,Set()) {0,0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x800 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x757
Type: StreamOut[Tup2[Fix[TRUE,_24,_8],Bit]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x757 = StreamOutNew(BurstFullDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x799 = StreamOutWrite(x757,x798,Set()) {0,0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x800 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x799 {0,0}
  Added dispatch 0 to x799 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x799 {0,0}
  Added dispatch 0 to x799 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x682
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x682 = FIFONew(Const(16))
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x715 {0} [x722 (stage: -1)]
  1 Read Groups:
  Group #0
    x715 = FIFODeq(x682,Set(Const(true))) rd{0}
     b495     c   mod
        1     0     0rd
  Grouping 1 Writes: 
    Access: x707 {0} [x708 (stage: -1)]
  1 Write Groups:
  Group #0
    x707 = FIFOEnq(x682,x706,Set(Const(true))) wr{0}
     b491     c   mod
        1     0     0wr



Merging memory instance groups:
Group #0: 
  Dephasing Iters: x715 = FIFODeq(x682,Set(Const(true))) rd{0}
 b495     c   mod
    1     0     0rd -> x722
  Leaf: x722, Iters: ListBuffer(b495), target: x735, elements: ListBuffer(b495)
  Current: x722
  Leaf: x722, Iters: ListBuffer(b495), target: x735, elements: List(0)
  Current: x722
  Leaf: x722, Iters: ListBuffer(b495), target: x735, elements: List(0)
  Current: x722
  General read dephasing rules for x682: (b495,List(0)) -> (b495,0)
  Dephasing Iters: x707 = FIFOEnq(x682,x706,Set(Const(true))) wr{0}
 b491     c   mod
    1     0     0wr -> x708
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
  General write dephasing rules for x682: (b491,List(0)) -> (b491,0)
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 3.605258356619518 (LUTs: 0.04678362573099415%, FFs: 0.0029191753329684362%, BRAMs: 3.5555555555555554%)
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x682
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x682 = FIFONew(Const(16))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x707 = FIFOEnq(x682,x706,Set(Const(true))) {0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x708 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x715 = FIFODeq(x682,Set(Const(true))) {0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x722 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x715 {0}
  Added dispatch 0 to x715 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x707 {0}
  Added dispatch 0 to x707 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x715 {0}
  Added dispatch 0 to x715 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x707 {0}
  Added dispatch 0 to x707 {0}
---------------------------------------------------------------------
INFERRING...
Name: x615
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:44:38
Src:                      val numel_n = min(tileN.to[Int], N - nn)(Pass 28)
Symbol:     x615 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 4 Reads: 
    Access: x637 {0} [x651 (stage: -1)]
    Access: x694 {0} [x708 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
    Access: x740 {} [x753 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
      Group #1 conflicts: <none>
      Group #1 same port: <none> 
    Access: x772 {0} [x787 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
      Group #1 conflicts: <none>
      Group #1 same port: <none> 
      Group #2 conflicts: <none>
      Group #2 same port: <none> 
  4 Read Groups:
  Group #0
    x637 = RegRead(x615) rd{0}
       c  modrd
  Group #1
    x694 = RegRead(x615) rd{0}
       c  modrd
  Group #2
    x740 = RegRead(x615) rd{}
       c  modrd
  Group #3
    x772 = RegRead(x615) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x619 {} [x620 (stage: -1)]
  1 Write Groups:
  Group #0
    x619 = RegWrite(x615,x618,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x637 {0}: 
      x619 {}
    x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
    x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
  x637 <-> x619 # LCA: x807 (stage: -1), Dist: Some(1)
  x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
  Dephasing Iters: x637 = RegRead(x615) rd{0}
   c  modrd -> x651
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
  Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
  General read dephasing rules for x615: (b482,List(0)) -> (b482,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x637 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x619: RegWrite
    x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
        x637: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x615
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x637 = RegRead(x615) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x637 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x651 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x694 {0}: 
      x619 {}
    x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
    x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
  x694 <-> x619 # LCA: x807 (stage: -1), Dist: Some(2)
  x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
  Dephasing Iters: x694 = RegRead(x615) rd{0}
   c  modrd -> x708
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
  Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
  General read dephasing rules for x615: (b491,List(0)) -> (b491,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x694 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x619: RegWrite
    x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
        x694: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x615
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x694 = RegRead(x615) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x694 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x708 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x694 = Some(RegRead(x615)) - x637 = Some(RegRead(x615))
    Computing overlaps: x619 = Some(RegWrite(x615,x618,Set())) - x619 = Some(RegWrite(x615,x618,Set()))
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
      Preceding writes for x694 {0}: 
        x619 {}
      Preceding writes for x637 {0}: 
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
    x694 <-> x619 # LCA: x807 (stage: -1), Dist: Some(2)
    x637 <-> x619 # LCA: x807 (stage: -1), Dist: Some(1)
    x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
    Dephasing Iters: x694 = RegRead(x615) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Dephasing Iters: x637 = RegRead(x615) rd{0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    General read dephasing rules for x615: (b491,List(0)) -> (b491,0)
  - (b482,List(0)) -> (b482,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x694 = RegRead(x615) rd{0}
   c  modrd, x637 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x619: RegWrite
      x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x637: RegRead
      x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x694: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x615
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 1.3519718837323191 (LUTs: 0.017543859649122806%, FFs: 0.0010946907498631637%, BRAMs: 1.3333333333333333%)
    ***** Cost summary *****
    Cost: 1.3519718837323191 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x694 = RegRead(x615) rd{0}
        grp 0:    c  modrd
        grp 2: x637 = RegRead(x615) rd{0}
        grp 2:    c  modrd
      Writes:
        grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x637 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x651 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x694 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x708 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 1 into instance 0
Group #2: 
    Preceding writes for x740 {}: 
      x619 {}
    x740 <-> x619: LCA: x807 (stage: -1), coarse-dist: 3
    x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
  x740 <-> x619 # LCA: x807 (stage: -1), Dist: Some(3)
  x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x740 = RegRead(x615) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x619: RegWrite
    x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
      x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
  **************************************************************************************
  Analyzing costs for banking schemes found for x615
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
  ***** Cost summary *****
  Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x740 = RegRead(x615) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    4
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x740 = RegRead(x615) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x753 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x740 = Some(RegRead(x615)) - x694 = Some(RegRead(x615))
    Computing overlaps: x740 = Some(RegRead(x615)) - x637 = Some(RegRead(x615))
    Computing overlaps: x619 = Some(RegWrite(x615,x618,Set())) - x619 = Some(RegWrite(x615,x618,Set()))
      x740 <-> x619: LCA: x807 (stage: -1), coarse-dist: 3
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
      Preceding writes for x740 {}: 
        x619 {}
      Preceding writes for x694 {0}: 
      Preceding writes for x637 {0}: 
      x740 <-> x619: LCA: x807 (stage: -1), coarse-dist: 3
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
    x740 <-> x619 # LCA: x807 (stage: -1), Dist: Some(3)
    x694 <-> x619 # LCA: x807 (stage: -1), Dist: Some(2)
    x637 <-> x619 # LCA: x807 (stage: -1), Dist: Some(1)
    x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
    Dephasing Iters: x694 = RegRead(x615) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Dephasing Iters: x637 = RegRead(x615) rd{0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    General read dephasing rules for x615: (b491,List(0)) -> (b491,0)
  - (b482,List(0)) -> (b482,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x740 = RegRead(x615) rd{}
   c  modrd, x694 = RegRead(x615) rd{0}
   c  modrd, x637 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x619: RegWrite
      x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x637: RegRead
      x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x694: RegRead
      x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    **************************************************************************************
    Analyzing costs for banking schemes found for x615
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 3 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 2.7039437674646383 (LUTs: 0.03508771929824561%, FFs: 0.0021893814997263274%, BRAMs: 2.6666666666666665%)
    ***** Cost summary *****
    Cost: 2.7039437674646383 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x740 = RegRead(x615) rd{}
        grp 0:    c  modrd
        grp 2: x694 = RegRead(x615) rd{0}
        grp 2:    c  modrd
        grp 2: x637 = RegRead(x615) rd{0}
        grp 2:    c  modrd
      Writes:
        grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    4
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x637 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x651 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x694 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x708 (scope: 0, 0)
3 [Type:WR]:
3 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x740 = RegRead(x615) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x753 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 2 into instance 0
Group #3: 
    Preceding writes for x772 {0}: 
      x619 {}
    x772 <-> x619: LCA: x807 (stage: -1), coarse-dist: 4
    x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
  x772 <-> x619 # LCA: x807 (stage: -1), Dist: Some(4)
  x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
  Dephasing Iters: x772 = RegRead(x615) rd{0}
   c  modrd -> x787
  Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: ListBuffer(b500)
  Current: x787
  Current: x801
  Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
  Current: x787
  Current: x801
  Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
  Current: x787
  Current: x801
  General read dephasing rules for x615: (b500,List(0)) -> (b500,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x772 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x619: RegWrite
    x806: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x805: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
          x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
            x772: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x615
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 1.1266432364435994 (LUTs: 0.014619883040935672%, FFs: 9.122422915526364E-4%, BRAMs: 1.1111111111111112%)
  ***** Cost summary *****
  Cost: 1.1266432364435994 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x772 = RegRead(x615) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    5
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
3 [Type:WR]:
3 [Type:RD]:
4 [Type:WR]:
4 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x772 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x787 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #3 with instance #0: 
    Computing overlaps: x772 = Some(RegRead(x615)) - x740 = Some(RegRead(x615))
    Computing overlaps: x772 = Some(RegRead(x615)) - x694 = Some(RegRead(x615))
    Computing overlaps: x772 = Some(RegRead(x615)) - x637 = Some(RegRead(x615))
    Computing overlaps: x619 = Some(RegWrite(x615,x618,Set())) - x619 = Some(RegWrite(x615,x618,Set()))
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x772 <-> x619: LCA: x807 (stage: -1), coarse-dist: 4
      x740 <-> x619: LCA: x807 (stage: -1), coarse-dist: 3
      Preceding writes for x772 {0}: 
        x619 {}
      Preceding writes for x740 {}: 
      Preceding writes for x694 {0}: 
      Preceding writes for x637 {0}: 
      x619 <-> x619: LCA: x620 (stage: -1), coarse-dist: <None>
      x637 <-> x619: LCA: x807 (stage: -1), coarse-dist: 1
      x694 <-> x619: LCA: x807 (stage: -1), coarse-dist: 2
      x772 <-> x619: LCA: x807 (stage: -1), coarse-dist: 4
      x740 <-> x619: LCA: x807 (stage: -1), coarse-dist: 3
    x619 <-> x619 # LCA: x807 (stage: -1), Dist: Some(0)
    x637 <-> x619 # LCA: x807 (stage: -1), Dist: Some(1)
    x694 <-> x619 # LCA: x807 (stage: -1), Dist: Some(2)
    x772 <-> x619 # LCA: x807 (stage: -1), Dist: Some(4)
    x740 <-> x619 # LCA: x807 (stage: -1), Dist: Some(3)
    Dephasing Iters: x772 = RegRead(x615) rd{0}
   c  modrd -> x787
    Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: ListBuffer(b500)
    Current: x787
    Current: x801
    Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
    Current: x787
    Current: x801
    Leaf: x787, Iters: ListBuffer(b500), target: x805, elements: List(0)
    Current: x787
    Current: x801
    Dephasing Iters: x694 = RegRead(x615) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
    Dephasing Iters: x637 = RegRead(x615) rd{0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
    General read dephasing rules for x615: (b500,List(0)) -> (b500,0)
  - (b491,List(0)) -> (b491,0)
  - (b482,List(0)) -> (b482,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x772 = RegRead(x615) rd{0}
   c  modrd, x740 = RegRead(x615) rd{}
   c  modrd, x694 = RegRead(x615) rd{0}
   c  modrd, x637 = RegRead(x615) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x620: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x619: RegWrite
      x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x637: RegRead
      x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x694: RegRead
      x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
      x806: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x805: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
          x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
            x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
              x772: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x615
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 4 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 4 | 1 |
            - Duplicate costs 4.506572945774398 (LUTs: 0.05847953216374269%, FFs: 0.0036489691662105455%, BRAMs: 4.444444444444445%)
    ***** Cost summary *****
    Cost: 4.506572945774398 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x772 = RegRead(x615) rd{0}
        grp 0:    c  modrd
        grp 2: x740 = RegRead(x615) rd{}
        grp 2:    c  modrd
        grp 2: x694 = RegRead(x615) rd{0}
        grp 2:    c  modrd
        grp 2: x637 = RegRead(x615) rd{0}
        grp 2:    c  modrd
      Writes:
        grp 0: x619 = RegWrite(x615,x618,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    5
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x620 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x637 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x651 (scope: 0, 0)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x694 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x708 (scope: 0, 0)
3 [Type:WR]:
3 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x740 = RegRead(x615) {}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x753 (scope: -1, -1)
4 [Type:WR]:
4 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x772 = RegRead(x615) {0}
      - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
      - Scope: x787 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 3 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: x615
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:44:38
Src:                      val numel_n = min(tileN.to[Int], N - nn)(Pass 28)
Symbol:     x615 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    5
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: x807 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x619 = RegWrite(x615,x618,Set()) {}
        - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
        - Scope: x620 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x637 = RegRead(x615) {0}
        - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
        - Scope: x651 (scope: 0, 0)
  2 [Type:WR]:
  2 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x694 = RegRead(x615) {0}
        - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
        - Scope: x708 (scope: 0, 0)
  3 [Type:WR]:
  3 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x740 = RegRead(x615) {}
        - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
        - Scope: x753 (scope: -1, -1)
  4 [Type:WR]:
  4 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x772 = RegRead(x615) {0}
        - Lab2GEMM.scala:44:38: val numel_n = min(tileN.to[Int], N - nn)(Pass 28)(Pass 28)
        - Scope: x787 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(4),0,0,List(0),List(0)) to x772 {0}
  Added dispatch 0 to x772 {0}
  Added port Port(Some(3),0,0,List(0),List(0)) to x740 {}
  Added dispatch 0 to x740 {}
  Added port Port(Some(2),0,0,List(0),List(0)) to x694 {0}
  Added dispatch 0 to x694 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x637 {0}
  Added dispatch 0 to x637 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x619 {}
  Added dispatch 0 to x619 {}
  Added port Port(Some(4),0,0,List(0),List(0)) to x772 {0}
  Added dispatch 0 to x772 {0}
  Added port Port(Some(3),0,0,List(0),List(0)) to x740 {}
  Added dispatch 0 to x740 {}
  Added port Port(Some(2),0,0,List(0),List(0)) to x694 {0}
  Added dispatch 0 to x694 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x637 {0}
  Added dispatch 0 to x637 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x619 {}
  Added dispatch 0 to x619 {}
---------------------------------------------------------------------
INFERRING...
Name: tileA_sram (x554)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:41:41
Src:                  val tileA_sram = SRAM[T](tileM, tileK)
Symbol:     x554 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
Effort:    1
BankingViews:   List(Flat(2), Hierarchical(2,None))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)), RegroupDims(List(1)), RegroupDims(List(0, 1)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x747 {0,0,0,0} [x752 (stage: -1)]
  1 Read Groups:
  Group #0
    x747 = SRAMRead(x554,List(b84, b90),Set()) rd{0,0,0,0}
     b84  b90    c  mod
       1    0    0    0
       0    1    0    0rd
  Grouping 1 Writes: 
    Access: x608 {0,0} [x609 (stage: -1)]
  1 Write Groups:
  Group #0
    x608 = SRAMWrite(x554,x607,List(b477, x606),Set(x605)) wr{0,0}
     b477  b223  b870     c   mod
        1     0     0     0     0
        0     1    -1     0     0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x747 {0,0,0,0}: 
      x608 {0,0}
    x747 <-> x608: LCA: x808 (stage: -1), coarse-dist: 1
    x608 <-> x608: LCA: x609 (stage: -1), coarse-dist: <None>
  x747 <-> x608 # LCA: x808 (stage: -1), Dist: Some(1)
  x608 <-> x608 # LCA: x808 (stage: -1), Dist: Some(0)
  Dephasing Iters: x747 = SRAMRead(x554,List(b84, b90),Set()) rd{0,0,0,0}
 b84  b90    c  mod
   1    0    0    0
   0    1    0    0rd -> x752
  Leaf: x752, Iters: ListBuffer(b69, b84, b87, b90), target: x807, elements: ListBuffer(b69, b84, b87, b90)
  Leaf: x752, Iters: ListBuffer(b69, b84, b87, b90), target: x807, elements: List(0, 0, 0, 0)
  Leaf: x752, Iters: ListBuffer(b69, b84, b87, b90), target: x807, elements: List(0, 0, 0, 0)
  General read dephasing rules for x554: (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b84,List(0, 0, 0, 0)) -> (b84,0)
  - (b87,List(0, 0, 0, 0)) -> (b87,0)
  - (b90,List(0, 0, 0, 0)) -> (b90,0)
  Dephasing Iters: x608 = SRAMWrite(x554,x607,List(b477, x606),Set(x605)) wr{0,0}
 b477  b223  b870     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x609
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: ListBuffer(b477, b223)
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: List(0, 0)
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: List(0, 0)
  General write dephasing rules for x554: (b477,List(0, 0)) -> (b477,0)
  - (b223,List(0, 0)) -> (b223,0)
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x747 = SRAMRead(x554,List(b84, b90),Set()) rd{0,0,0,0}
 b84  b90    c  mod
   1    0    0    0
   0    1    0    0rd), Set()) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x610: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x609: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x608: SRAMWrite
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
          x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
            x747: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for tileA_sram (x554)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 115.36826741182458 (SRAM LUTs: 1.4970760233918128%, FFs: 0.09341361065498996%, BRAMs: 113.77777777777777%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 115.36826741182458 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x747 = SRAMRead(x554,List(b84, b90),Set()) rd{0,0,0,0}
      grp 0:  b84  b90    c  mod
      grp 0:    1    0    0    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x608 = SRAMWrite(x554,x607,List(b477, x606),Set(x605)) wr{0,0}
      grp 0:  b477  b223  b870     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x608 = SRAMWrite(x554,x607,List(b477, x606),Set(x605)) {0,0}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x609 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x747 = SRAMRead(x554,List(b84, b90),Set()) {0,0,0,0}
      - Lab2GEMM.scala:54:75: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
      - Scope: x752 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: tileA_sram (x554)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:41:41
Src:                  val tileA_sram = SRAM[T](tileM, tileK)
Symbol:     x554 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    2
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x808 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x608 = SRAMWrite(x554,x607,List(b477, x606),Set(x605)) {0,0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x609 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x747 = SRAMRead(x554,List(b84, b90),Set()) {0,0,0,0}
        - Lab2GEMM.scala:54:75: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
        - Scope: x752 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x747 {0,0,0,0}
  Added dispatch 0 to x747 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x608 {0,0}
  Added dispatch 0 to x608 {0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x747 {0,0,0,0}
  Added dispatch 0 to x747 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x608 {0,0}
  Added dispatch 0 to x608 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: tileC_sram (x622)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:46:45
Src:                      val tileC_sram = SRAM[T](tileM, tileN).buffer
Symbol:     x622 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
Effort:    1
BankingViews:   List(Flat(2), Hierarchical(2,None))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)), RegroupDims(List(1)), RegroupDims(List(0, 1)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 2 Reads: 
    Access: x746 {0,0,0} [x752 (stage: -1)]
    Access: x797 {0,0} [x800 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Read Groups:
  Group #0
    x746 = SRAMRead(x622,List(b84, b87),Set()) rd{0,0,0}
     b84  b87    c  mod
       1    0    0    0
       0    1    0    0rd
  Group #1
    x797 = SRAMRead(x622,List(b500, x796),Set(x795)) rd{0,0}
     b500  b874  b875  b876  b405     c   mod
        1     0     0     0     0     0     0
        0   -16    16     1     1     0     0rd
  Grouping 2 Writes: 
    Access: x733 {0,0} [x734 (stage: -1)]
    Access: x751 {0,0,0} [x752 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
  2 Write Groups:
  Group #0
    x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
     b495  b352  b872     c   mod
        1     0     0     0     0
        0     1    -1     0     0wr
  Group #1
    x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
     b84  b87    c  mod
       1    0    0    0
       0    1    0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x746 {0,0,0}: 
      x733 {0,0}
      x751 {0,0,0}
  Mustfollow: x733 -> x751 -> x746 [true]
    CtrlA: x752 (stage: -1) [0]
    CtrlB: x807 (stage: -1) [1]
    IsStream: false
  Mustfollow: x751 -> x733 -> x746 [true]
    CtrlA: x807 (stage: -1) [1]
    CtrlB: x752 (stage: -1) [0]
    IsStream: false
    x746 <-> x733: LCA: x807 (stage: -1), coarse-dist: 1
    x733 <-> x733: LCA: x734 (stage: -1), coarse-dist: <None>
    x751 <-> x733: LCA: x807 (stage: -1), coarse-dist: 1
    x746 <-> x751: LCA: x752 (stage: -1), coarse-dist: <None>
    x733 <-> x751: LCA: x807 (stage: -1), coarse-dist: -1
    x751 <-> x751: LCA: x752 (stage: -1), coarse-dist: <None>
  x746 <-> x733 # LCA: x807 (stage: -1), Dist: Some(1)
  x733 <-> x733 # LCA: x807 (stage: -1), Dist: Some(0)
  x751 <-> x733 # LCA: x807 (stage: -1), Dist: Some(1)
  Dephasing Iters: x746 = SRAMRead(x622,List(b84, b87),Set()) rd{0,0,0}
 b84  b87    c  mod
   1    0    0    0
   0    1    0    0rd -> x752
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: ListBuffer(b84, b87, b90)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  General read dephasing rules for x622: (b84,List(0, 0, 0)) -> (b84,0)
  - (b87,List(0, 0, 0)) -> (b87,0)
  - (b90,List(0, 0, 0)) -> (b90,0)
  Dephasing Iters: x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
 b495  b352  b872     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x734
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: ListBuffer(b495, b352)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  Dephasing Iters: x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
 b84  b87    c  mod
   1    0    0    0
   0    1    0    0wr -> x752
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: ListBuffer(b84, b87, b90)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  General write dephasing rules for x622: (b495,List(0, 0)) -> (b495,0)
  - (b84,List(0, 0, 0)) -> (b84,0)
  - (b352,List(0, 0)) -> (b352,0)
  - (b87,List(0, 0, 0)) -> (b87,0)
  - (b90,List(0, 0, 0)) -> (b90,0)
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x746 = SRAMRead(x622,List(b84, b87),Set()) rd{0,0,0}
 b84  b87    c  mod
   1    0    0    0
   0    1    0    0rd), Set()) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x735: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x733: SRAMWrite
    x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
      x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x746: SRAMRead
          x751: SRAMWrite
  **************************************************************************************
  Analyzing costs for banking schemes found for tileC_sram (x622)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 115.36826741182458 (SRAM LUTs: 1.4970760233918128%, FFs: 0.09341361065498996%, BRAMs: 113.77777777777777%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 115.36826741182458 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x746 = SRAMRead(x622,List(b84, b87),Set()) rd{0,0,0}
      grp 0:  b84  b87    c  mod
      grp 0:    1    0    0    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
      grp 0:  b495  b352  b872     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
      grp 1: x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
      grp 1:  b84  b87    c  mod
      grp 1:    1    0    0    0
      grp 1:    0    1    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List(0, 0)
Accum:    Fold
Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) {0,0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) {0,0,0}
      - Lab2GEMM.scala:54:44: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
      - Scope: x752 (scope: 0, 0)
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x746 = SRAMRead(x622,List(b84, b87),Set()) {0,0,0}
      - Lab2GEMM.scala:54:56: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
      - Scope: x752 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x797 {0,0}: 
      x733 {0,0}
      x751 {0,0,0}
  Mustfollow: x733 -> x751 -> x797 [true]
    CtrlA: x807 (stage: -1) [1]
    CtrlB: x807 (stage: -1) [2]
    IsStream: false
    ctrlAB: x807 (stage: -1)
  Mustfollow: x751 -> x733 -> x797 [true]
    CtrlA: x807 (stage: -1) [2]
    CtrlB: x807 (stage: -1) [1]
    IsStream: false
    ctrlAB: x807 (stage: -1)
    x797 <-> x733: LCA: x807 (stage: -1), coarse-dist: 2
    x733 <-> x733: LCA: x734 (stage: -1), coarse-dist: <None>
    x751 <-> x733: LCA: x807 (stage: -1), coarse-dist: 1
    x797 <-> x751: LCA: x807 (stage: -1), coarse-dist: 1
    x733 <-> x751: LCA: x807 (stage: -1), coarse-dist: -1
    x751 <-> x751: LCA: x752 (stage: -1), coarse-dist: <None>
  x797 <-> x733 # LCA: x807 (stage: -1), Dist: Some(2)
  x733 <-> x733 # LCA: x807 (stage: -1), Dist: Some(0)
  x751 <-> x733 # LCA: x807 (stage: -1), Dist: Some(1)
  Dephasing Iters: x797 = SRAMRead(x622,List(b500, x796),Set(x795)) rd{0,0}
 b500  b874  b875  b876  b405     c   mod
    1     0     0     0     0     0     0
    0   -16    16     1     1     0     0rd -> x800
  Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: ListBuffer(b500, b405)
  Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: List(0, 0)
  Leaf: x800, Iters: ListBuffer(b500, b405), target: x805, elements: List(0, 0)
  General read dephasing rules for x622: (b500,List(0, 0)) -> (b500,0)
  - (b405,List(0, 0)) -> (b405,0)
  Dephasing Iters: x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
 b495  b352  b872     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x734
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: ListBuffer(b495, b352)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
  Dephasing Iters: x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
 b84  b87    c  mod
   1    0    0    0
   0    1    0    0wr -> x752
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: ListBuffer(b84, b87, b90)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  General write dephasing rules for x622: (b495,List(0, 0)) -> (b495,0)
  - (b84,List(0, 0, 0)) -> (b84,0)
  - (b352,List(0, 0)) -> (b352,0)
  - (b87,List(0, 0, 0)) -> (b87,0)
  - (b90,List(0, 0, 0)) -> (b90,0)
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x797 = SRAMRead(x622,List(b500, x796),Set(x795)) rd{0,0}
 b500  b874  b875  b876  b405     c   mod
    1     0     0     0     0     0     0
    0   -16    16     1     1     0     0rd), Set()) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x735: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x733: SRAMWrite
    x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
      x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x751: SRAMWrite
    x806: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x805: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
          x800: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
            x797: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for tileC_sram (x622)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 2 |
          - Duplicate costs 173.05240111773685 (SRAM LUTs: 2.245614035087719%, FFs: 0.14012041598248495%, BRAMs: 170.66666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 173.05240111773685 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x797 = SRAMRead(x622,List(b500, x796),Set(x795)) rd{0,0}
      grp 0:  b500  b874  b875  b876  b405     c   mod
      grp 0:     1     0     0     0     0     0     0
      grp 0:     0   -16    16     1     1     0     0rd
    Writes:
      grp 0: x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
      grp 0:  b495  b352  b872     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
      grp 1: x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
      grp 1:  b84  b87    c  mod
      grp 1:    1    0    0    0
      grp 1:    0    1    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List(0, 0)
Accum:    Fold
Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) {0,0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) {0,0,0}
      - Lab2GEMM.scala:54:44: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
      - Scope: x752 (scope: 0, 0)
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x797 = SRAMRead(x622,List(b500, x796),Set(x795)) {0,0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x800 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x797 = Some(SRAMRead(x622,List(b500, x796),Set(x795))) - x746 = Some(SRAMRead(x622,List(b84, b87),Set()))
    Computing overlaps: x733 = Some(SRAMWrite(x622,x732,List(b495, x731),Set(x730))) - x733 = Some(SRAMWrite(x622,x732,List(b495, x731),Set(x730)))
    Dephasing Iters: x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) wr{0,0}
 b495  b352  b872     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x734
    Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: ListBuffer(b495, b352)
    Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
    Leaf: x734, Iters: ListBuffer(b495, b352), target: x735, elements: List(0, 0)
    Computing overlaps: x733 = Some(SRAMWrite(x622,x732,List(b495, x731),Set(x730))) - x751 = Some(SRAMWrite(x622,x750,List(b84, b87),Set()))
    Computing overlaps: x751 = Some(SRAMWrite(x622,x750,List(b84, b87),Set())) - x733 = Some(SRAMWrite(x622,x732,List(b495, x731),Set(x730)))
    Computing overlaps: x751 = Some(SRAMWrite(x622,x750,List(b84, b87),Set())) - x751 = Some(SRAMWrite(x622,x750,List(b84, b87),Set()))
    Dephasing Iters: x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) wr{0,0,0}
 b84  b87    c  mod
   1    0    0    0
   0    1    0    0wr -> x752
    Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: ListBuffer(b84, b87, b90)
    Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
    Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
      x797 <-> x733: LCA: x807 (stage: -1), coarse-dist: 2
      x746 <-> x733: LCA: x807 (stage: -1), coarse-dist: 1
      x733 <-> x733: LCA: x734 (stage: -1), coarse-dist: <None>
      x751 <-> x733: LCA: x807 (stage: -1), coarse-dist: 1
      x797 <-> x751: LCA: x807 (stage: -1), coarse-dist: 1
      x746 <-> x751: LCA: x752 (stage: -1), coarse-dist: <None>
      x733 <-> x751: LCA: x807 (stage: -1), coarse-dist: -1
      x751 <-> x751: LCA: x752 (stage: -1), coarse-dist: <None>
    Did not merge 1 into instance 0: Accumulator conflict (A Type: Fold, B Type: Fold)
  Result: Created instance #1
---------------------------------------------------------------------
SUMMARY: 
Name: tileC_sram (x622)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:46:45
Src:                      val tileC_sram = SRAM[T](tileM, tileN).buffer
Symbol:     x622 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
---------------------------------------------------------------------
Instances: 2
Instance #0
  <Banked>
  Depth:    2
  Padding:  List(0, 0)
  Accum:    Fold
  Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x807 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) {0,0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) {0,0,0}
        - Lab2GEMM.scala:54:44: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
        - Scope: x752 (scope: 0, 0)
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x746 = SRAMRead(x622,List(b84, b87),Set()) {0,0,0}
        - Lab2GEMM.scala:54:56: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
        - Scope: x752 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



Instance #1
  <Banked>
  Depth:    3
  Padding:  List(0, 0)
  Accum:    Fold
  Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x807 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x733 = SRAMWrite(x622,x732,List(b495, x731),Set(x730)) {0,0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x751 = SRAMWrite(x622,x750,List(b84, b87),Set()) {0,0,0}
        - Lab2GEMM.scala:54:44: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
        - Scope: x752 (scope: 0, 0)
  1 [Type:RD]:
  2 [Type:WR]:
  2 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x797 = SRAMRead(x622,List(b500, x796),Set(x795)) {0,0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x800 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x746 {0,0,0}
  Added dispatch 0 to x746 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x733 {0,0}
  Added dispatch 0 to x733 {0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x751 {0,0,0}
  Added dispatch 0 to x751 {0,0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x746 {0,0,0}
  Added dispatch 0 to x746 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x733 {0,0}
  Added dispatch 0 to x733 {0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x751 {0,0,0}
  Added dispatch 0 to x751 {0,0,0}
  Added port Port(Some(2),0,0,List(0),List(0)) to x797 {0,0}
  Added dispatch 1 to x797 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x733 {0,0}
  Added dispatch 1 to x733 {0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x751 {0,0,0}
  Added dispatch 1 to x751 {0,0,0}
  Added port Port(Some(2),0,0,List(0),List(0)) to x797 {0,0}
  Added dispatch 1 to x797 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x733 {0,0}
  Added dispatch 1 to x733 {0,0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x751 {0,0,0}
  Added dispatch 1 to x751 {0,0,0}
---------------------------------------------------------------------
INFERRING...
Name: x657
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x657 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x666 {} [x677 (stage: -1)]
  1 Read Groups:
  Group #0
    x666 = RegRead(x657) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x664 {} [x665 (stage: -1)]
  1 Write Groups:
  Group #0
    x664 = RegWrite(x657,x663,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x666 {}: 
      x664 {}
    x666 <-> x664: LCA: x678 (stage: -1), coarse-dist: <None>
    x664 <-> x664: LCA: x665 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x666 = RegRead(x657) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x678: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x665: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x664: RegWrite
    x677: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x666: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x657
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x666 = RegRead(x657) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x664 = RegWrite(x657,x663,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x664 = RegWrite(x657,x663,Set()) {}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x665 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x666 = RegRead(x657) {}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x677 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x657
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x657 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x664 = RegWrite(x657,x663,Set()) {}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x665 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x666 = RegRead(x657) {}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x677 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x666 {}
  Added dispatch 0 to x666 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x664 {}
  Added dispatch 0 to x664 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x666 {}
  Added dispatch 0 to x666 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x664 {}
  Added dispatch 0 to x664 {}
---------------------------------------------------------------------
INFERRING...
Name: x558
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x558 = StreamInNew(BurstDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x607 {0,0} [x609 (stage: -1)]
  1 Read Groups:
  Group #0
    x607 = StreamInRead(x558,Set()) rd{0,0}
     b477  b223     c   mod
        1     1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x607 {0,0}: 
  Dephasing Iters: x607 = StreamInRead(x558,Set()) rd{0,0}
 b477  b223     c   mod
    1     1     0     0rd -> x609
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: ListBuffer(b477, b223)
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: List(0, 0)
  Leaf: x609, Iters: ListBuffer(b477, b223), target: x610, elements: List(0, 0)
  General read dephasing rules for x558: (b477,List(0, 0)) -> (b477,0)
  - (b223,List(0, 0)) -> (b223,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x607 = StreamInRead(x558,Set()) rd{0,0}
 b477  b223     c   mod
    1     1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x609: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
    x607: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x558
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x607 = StreamInRead(x558,Set()) rd{0,0}
      grp 0:  b477  b223     c   mod
      grp 0:     1     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x607 = StreamInRead(x558,Set()) {0,0}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x609 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x558
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x558 = StreamInNew(BurstDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x607 = StreamInRead(x558,Set()) {0,0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x609 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x607 {0,0}
  Added dispatch 0 to x607 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x607 {0,0}
  Added dispatch 0 to x607 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x713
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x713 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x728 {0} [x734 (stage: -1)]
  1 Read Groups:
  Group #0
    x728 = RegRead(x713) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x719 {} [x722 (stage: -1)]
  1 Write Groups:
  Group #0
    x719 = RegWrite(x713,x718,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x728 {0}: 
      x719 {}
    x728 <-> x719: LCA: x735 (stage: -1), coarse-dist: <None>
    x719 <-> x719: LCA: x722 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x728 = RegRead(x713) rd{0}
   c  modrd -> x734
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: ListBuffer(b352)
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: List(0)
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: List(0)
  General read dephasing rules for x713: (b352,List(0)) -> (b352,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x728 = RegRead(x713) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x735: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x722: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x719: RegWrite
    x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x728: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x713
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x728 = RegRead(x713) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x719 = RegWrite(x713,x718,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x719 = RegWrite(x713,x718,Set()) {}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x722 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x728 = RegRead(x713) {0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x713
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x713 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x719 = RegWrite(x713,x718,Set()) {}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x722 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x728 = RegRead(x713) {0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x728 {0}
  Added dispatch 0 to x728 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x719 {}
  Added dispatch 0 to x719 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x728 {0}
  Added dispatch 0 to x728 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x719 {}
  Added dispatch 0 to x719 {}
---------------------------------------------------------------------
INFERRING...
Name: x681
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x681 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x705 {0} [x708 (stage: -1)]
  1 Write Groups:
  Group #0
    x705 = StreamOutWrite(x681,x703,Set(x704)) wr{0}
     b491     c   mod
        1     0     0wr
  x705 <-> x705: LCA: x708 (stage: -1), coarse-dist: <None>
Dephasing Iters: x705 = StreamOutWrite(x681,x703,Set(x704)) wr{0}
 b491     c   mod
    1     0     0wr -> x708
Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: ListBuffer(b491)
Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
Leaf: x708, Iters: ListBuffer(b491), target: x708, elements: List(0)
General write dephasing rules for x681: (b491,List(0)) -> (b491,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
  x705: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x681
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x705 = StreamOutWrite(x681,x703,Set(x704)) wr{0}
    grp 0:  b491     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x705 = StreamOutWrite(x681,x703,Set(x704)) {0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x708 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x681
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x681 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x705 = StreamOutWrite(x681,x703,Set(x704)) {0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x708 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x705 {0}
  Added dispatch 0 to x705 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x705 {0}
  Added dispatch 0 to x705 {0}
---------------------------------------------------------------------
INFERRING...
Name: x758
Type: StreamIn[Bit]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x758 = StreamInNew(BurstAckBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x803 {0} [x804 (stage: -1)]
  1 Read Groups:
  Group #0
    x803 = StreamInRead(x758,Set()) rd{0}
     b500     c   mod
        1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x803 {0}: 
  Dephasing Iters: x803 = StreamInRead(x758,Set()) rd{0}
 b500     c   mod
    1     0     0rd -> x804
  Leaf: x804, Iters: ListBuffer(b500), target: x805, elements: ListBuffer(b500)
  Current: x804
  Leaf: x804, Iters: ListBuffer(b500), target: x805, elements: List(0)
  Current: x804
  Leaf: x804, Iters: ListBuffer(b500), target: x805, elements: List(0)
  Current: x804
  General read dephasing rules for x758: (b500,List(0)) -> (b500,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x803 = StreamInRead(x758,Set()) rd{0}
 b500     c   mod
    1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x804: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
    x803: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x758
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x803 = StreamInRead(x758,Set()) rd{0}
      grp 0:  b500     c   mod
      grp 0:     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x803 = StreamInRead(x758,Set()) {0}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x804 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x758
Type: StreamIn[Bit]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x758 = StreamInNew(BurstAckBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x803 = StreamInRead(x758,Set()) {0}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x804 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x803 {0}
  Added dispatch 0 to x803 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x803 {0}
  Added dispatch 0 to x803 {0}
---------------------------------------------------------------------
INFERRING...
Name: tileB_sram (x621)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:45:45
Src:                      val tileB_sram = SRAM[T](tileK, tileN)
Symbol:     x621 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
Effort:    1
BankingViews:   List(Flat(2), Hierarchical(2,None))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()), RegroupDims(List(0)), RegroupDims(List(1)), RegroupDims(List(0, 1)))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x748 {0,0,0} [x752 (stage: -1)]
  1 Read Groups:
  Group #0
    x748 = SRAMRead(x621,List(b90, b87),Set()) rd{0,0,0}
     b90  b87    c  mod
       1    0    0    0
       0    1    0    0rd
  Grouping 1 Writes: 
    Access: x676 {0,0} [x677 (stage: -1)]
  1 Write Groups:
  Group #0
    x676 = SRAMWrite(x621,x675,List(b486, x674),Set(x673)) wr{0,0}
     b486  b289  b871     c   mod
        1     0     0     0     0
        0     1    -1     0     0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x748 {0,0,0}: 
      x676 {0,0}
    x748 <-> x676: LCA: x807 (stage: -1), coarse-dist: 2
    x676 <-> x676: LCA: x677 (stage: -1), coarse-dist: <None>
  x748 <-> x676 # LCA: x807 (stage: -1), Dist: Some(2)
  x676 <-> x676 # LCA: x807 (stage: -1), Dist: Some(0)
  Dephasing Iters: x748 = SRAMRead(x621,List(b90, b87),Set()) rd{0,0,0}
 b90  b87    c  mod
   1    0    0    0
   0    1    0    0rd -> x752
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: ListBuffer(b84, b87, b90)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  Leaf: x752, Iters: ListBuffer(b84, b87, b90), target: x754, elements: List(0, 0, 0)
  General read dephasing rules for x621: (b84,List(0, 0, 0)) -> (b84,0)
  - (b87,List(0, 0, 0)) -> (b87,0)
  - (b90,List(0, 0, 0)) -> (b90,0)
  Dephasing Iters: x676 = SRAMWrite(x621,x675,List(b486, x674),Set(x673)) wr{0,0}
 b486  b289  b871     c   mod
    1     0     0     0     0
    0     1    -1     0     0wr -> x677
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: ListBuffer(b486, b289)
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: List(0, 0)
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: List(0, 0)
  General write dephasing rules for x621: (b486,List(0, 0)) -> (b486,0)
  - (b289,List(0, 0)) -> (b289,0)
  solution bankings are Map(BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x748 = SRAMRead(x621,List(b90, b87),Set()) rd{0,0,0}
 b90  b87    c  mod
   1    0    0    0
   0    1    0    0rd), Set()) -> List(List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))))
  x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x678: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x677: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x676: SRAMWrite
    x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
      x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
          x748: SRAMRead
  **************************************************************************************
  Analyzing costs for banking schemes found for tileB_sram (x621)
  Scheme BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 173.05240111773685 (SRAM LUTs: 2.245614035087719%, FFs: 0.14012041598248495%, BRAMs: 170.66666666666666%, Auxiliary LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
  ***** Cost summary *****
  Cost: 173.05240111773685 for version 0 of BankingOptions(Hierarchical(2,None),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x748 = SRAMRead(x621,List(b90, b87),Set()) rd{0,0,0}
      grp 0:  b90  b87    c  mod
      grp 0:    1    0    0    0
      grp 0:    0    1    0    0rd
    Writes:
      grp 0: x676 = SRAMWrite(x621,x675,List(b486, x674),Set(x673)) wr{0,0}
      grp 0:  b486  b289  b871     c   mod
      grp 0:     1     0     0     0     0
      grp 0:     0     1    -1     0     0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List(0, 0)
Accum:    None
Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
Pipeline: x807 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x676 = SRAMWrite(x621,x675,List(b486, x674),Set(x673)) {0,0}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x677 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x748 = SRAMRead(x621,List(b90, b87),Set()) {0,0,0}
      - Lab2GEMM.scala:54:94: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
      - Scope: x752 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: tileB_sram (x621)
Type: SRAM2[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:45:45
Src:                      val tileB_sram = SRAM[T](tileK, tileN)
Symbol:     x621 = SRAMNew(List(Const(16), Const(16)),SRAM2[Fix[TRUE,_24,_8]])
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    3
  Padding:  List(0, 0)
  Accum:    None
  Banking:  List(Dims {0,1}: Cyclic: N=1, B=1, alpha=<1,1>, P=<1,1> (1 solutions, 0 checks)) <Flat>
  Pipeline: x807 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x676 = SRAMWrite(x621,x675,List(b486, x674),Set(x673)) {0,0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x677 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
  2 [Type:WR]:
  2 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x748 = SRAMRead(x621,List(b90, b87),Set()) {0,0,0}
        - Lab2GEMM.scala:54:94: tileC_sram(m, n) = tileC_sram(m, n) + tileA_sram(m, k) * tileB_sram(k, n)
        - Scope: x752 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(2),0,0,List(0),List(0)) to x748 {0,0,0}
  Added dispatch 0 to x748 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x676 {0,0}
  Added dispatch 0 to x676 {0,0}
  Added port Port(Some(2),0,0,List(0),List(0)) to x748 {0,0,0}
  Added dispatch 0 to x748 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x676 {0,0}
  Added dispatch 0 to x676 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: x626
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x626 = StreamInNew(BurstDataBus())
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x675 {0,0} [x677 (stage: -1)]
  1 Read Groups:
  Group #0
    x675 = StreamInRead(x626,Set()) rd{0,0}
     b486  b289     c   mod
        1     1     0     0rd
  Grouping 0 Reads: 

  <No Read Groups>



Merging memory instance groups:
Group #0: 
    Preceding writes for x675 {0,0}: 
  Dephasing Iters: x675 = StreamInRead(x626,Set()) rd{0,0}
 b486  b289     c   mod
    1     1     0     0rd -> x677
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: ListBuffer(b486, b289)
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: List(0, 0)
  Leaf: x677, Iters: ListBuffer(b486, b289), target: x678, elements: List(0, 0)
  General read dephasing rules for x626: (b486,List(0, 0)) -> (b486,0)
  - (b289,List(0, 0)) -> (b289,0)
  solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set(x675 = StreamInRead(x626,Set()) rd{0,0}
 b486  b289     c   mod
    1     1     0     0rd), Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
  x677: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
    x675: StreamInRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x626
  Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 0 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x675 = StreamInRead(x626,Set()) rd{0,0}
      grp 0:  b486  b289     c   mod
      grp 0:     1     1     0     0rd
    Writes:
    Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x675 = StreamInRead(x626,Set()) {0,0}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x677 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x626
Type: StreamIn[Fix[TRUE,_24,_8]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x626 = StreamInNew(BurstDataBus())
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x675 = StreamInRead(x626,Set()) {0,0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x677 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x675 {0,0}
  Added dispatch 0 to x675 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x675 {0,0}
  Added dispatch 0 to x675 {0,0}
---------------------------------------------------------------------
INFERRING...
Name: N (x505)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:13:18
Src:      val N = ArgIn[Int]
Symbol:     x505 = ArgInNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 7 Reads: 
    Access: x528 {} [Host]
    Access: x531 {} [Host]
    Access: x612 {0} [x807 (stage: -1)]
    Access: x616 {0,0,0} [x620 (stage: -1)]
    Access: x630 {0,0,0,0} [x651 (stage: -1)]
    Access: x687 {0,0,0,0} [x708 (stage: -1)]
    Access: x765 {0,0,0,0} [x787 (stage: -1)]
  7 Read Groups:
  Group #0
    x528 = RegRead(x505) rd{}
       c  modrd
  Group #1
    x531 = RegRead(x505) rd{}
       c  modrd
  Group #2
    x612 = RegRead(x505) rd{0}
       c  modrd
  Group #3
    x616 = RegRead(x505) rd{0,0,0}
       c  modrd
  Group #4
    x630 = RegRead(x505) rd{0,0,0,0}
       c  modrd
  Group #5
    x687 = RegRead(x505) rd{0,0,0,0}
       c  modrd
  Group #6
    x765 = RegRead(x505) rd{0,0,0,0}
       c  modrd
  Grouping 1 Writes: 
    Access: x512 {} [Host]
  1 Write Groups:
  Group #0
    x512 = SetReg(x505,x511) wr{}
       c  modwr



Merging memory instance groups:
Group #4: 
    x687 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
  Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
  Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
  Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
  General read dephasing rules for x505: (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x687 = RegRead(x505) rd{0,0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)))
  Result: Created instance #0
Group #0: 
    x616 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
  Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
  Current: x620
  Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
  Current: x620
  Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
  Current: x620
  General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x616 = RegRead(x505) rd{0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x616 = RegRead(x505) rd{0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)))
  Attempting to merge group #0 with instance #0: 
    Computing overlaps: x616 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
    ***** Cost summary *****
    Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x616 = RegRead(x505) rd{0,0,0}
        grp 0:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)))
  Result: Merged 0 into instance 0
Group #6: 
    x531 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x531 = RegRead(x505) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Attempting to merge group #6 with instance #0: 
    Computing overlaps: x531 = Some(RegRead(x505)) - x616 = Some(RegRead(x505))
    Computing overlaps: x531 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x531 = RegRead(x505) rd{}
   c  modrd, x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set(x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 4 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
    ***** Cost summary *****
    Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 1: x531 = RegRead(x505) rd{}
        grp 1:    c  modrd
        grp 2: x616 = RegRead(x505) rd{0,0,0}
        grp 2:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Result: Merged 6 into instance 0
Group #5: 
    x528 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x528 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x528 = RegRead(x505) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x528 = RegRead(x505) {}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host))
  Attempting to merge group #5 with instance #0: 
    Computing overlaps: x528 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x528 = Some(RegRead(x505)) - x616 = Some(RegRead(x505))
    Computing overlaps: x528 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x528 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd, x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set(x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 6 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 4 | 1 |
            - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
    ***** Cost summary *****
    Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 1: x528 = RegRead(x505) rd{}
        grp 1:    c  modrd
        grp 2: x531 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x616 = RegRead(x505) rd{0,0,0}
        grp 2:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 3: x531 = RegRead(x505) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x528 = RegRead(x505) {}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Result: Merged 5 into instance 0
Group #2: 
    x630 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x651
  Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: ListBuffer(b50, b57, b69, b482)
  Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
  Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
  General read dephasing rules for x505: (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b482,List(0, 0, 0, 0)) -> (b482,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x630 = RegRead(x505) rd{0,0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x630 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: x651 (scope: 0, 0)))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x630 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x630 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x630 = Some(RegRead(x505)) - x616 = Some(RegRead(x505))
    Computing overlaps: x630 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x630 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x630 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Dephasing Iters: x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: ListBuffer(b50, b57, b69, b482)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b482,List(0, 0, 0, 0)) -> (b482,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd, x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set(), Set(x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 7 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 5 | 1 |
            - Duplicate costs 1.1266432364435994 (LUTs: 0.014619883040935672%, FFs: 9.122422915526364E-4%, BRAMs: 1.1111111111111112%)
    ***** Cost summary *****
    Cost: 1.1266432364435994 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x630 = RegRead(x505) rd{0,0,0,0}
        grp 0:    c  modrd
        grp 2: x528 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x531 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x616 = RegRead(x505) rd{0,0,0}
        grp 2:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 3: x528 = RegRead(x505) rd{}
        grp 3:    c  modrd
        grp 3: x531 = RegRead(x505) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x630 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: x651 (scope: 0, 0)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x528 = RegRead(x505) {}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Result: Merged 2 into instance 0
Group #1: 
    x612 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x612 = RegRead(x505) rd{0}
   c  modrd -> x807
  Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
  Current: x807
  Current: x808
  Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
  Current: x807
  Current: x808
  Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
  Current: x807
  Current: x808
  General read dephasing rules for x505: (b50,List(0)) -> (b50,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x612 = RegRead(x505) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x612 = RegRead(x505) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x612 = RegRead(x505) {0}
      - Lab2GEMM.scala:43:25: Foreach(N by tileN){nn =>
      - Scope: x807 (scope: -1, -1)))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x612 = Some(RegRead(x505)) - x616 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x630 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x612 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x612 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x612 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Dephasing Iters: x612 = RegRead(x505) rd{0}
   c  modrd -> x807
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x807
    Current: x808
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x807
    Current: x808
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x807
    Current: x808
    Dephasing Iters: x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: ListBuffer(b50, b57, b69, b482)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b50,List(0)) -> (b50,0)
  - (b482,List(0, 0, 0, 0)) -> (b482,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd, x612 = RegRead(x505) rd{0}
   c  modrd, x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set(), Set(x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 8 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 6 | 1 |
            - Duplicate costs 1.3519718837323191 (LUTs: 0.017543859649122806%, FFs: 0.0010946907498631637%, BRAMs: 1.3333333333333333%)
    ***** Cost summary *****
    Cost: 1.3519718837323191 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x612 = RegRead(x505) rd{0}
        grp 0:    c  modrd
        grp 2: x616 = RegRead(x505) rd{0,0,0}
        grp 2:    c  modrd
        grp 2: x528 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x531 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 2: x630 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 3: x528 = RegRead(x505) rd{}
        grp 3:    c  modrd
        grp 3: x531 = RegRead(x505) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x630 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: x651 (scope: 0, 0)
  [Ofs: 0] x612 = RegRead(x505) {0}
      - Lab2GEMM.scala:43:25: Foreach(N by tileN){nn =>
      - Scope: x807 (scope: -1, -1)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x528 = RegRead(x505) {}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Result: Merged 1 into instance 0
Group #3: 
    x765 <-> x512: LCA: Host, coarse-dist: <None>
    x512 <-> x512: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x765 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x787
  Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: ListBuffer(b50, b57, b69, b500)
  Current: x787
  Current: x801
  Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: List(0, 0, 0, 0)
  Current: x787
  Current: x801
  Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: List(0, 0, 0, 0)
  Current: x787
  Current: x801
  General read dephasing rules for x505: (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b500,List(0, 0, 0, 0)) -> (b500,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x765 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for N (x505)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x765 = RegRead(x505) rd{0,0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x512 = SetReg(x505,x511) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x765 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x787 (scope: 0, 0)))
  Attempting to merge group #3 with instance #0: 
    Computing overlaps: x765 = Some(RegRead(x505)) - x616 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x687 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x612 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x630 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x528 = Some(RegRead(x505))
    Computing overlaps: x765 = Some(RegRead(x505)) - x531 = Some(RegRead(x505))
    Computing overlaps: x512 = Some(SetReg(x505,x511)) - x512 = Some(SetReg(x505,x511))
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x765 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x612 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
      x687 <-> x512: LCA: Host, coarse-dist: <None>
      x512 <-> x512: LCA: Host, coarse-dist: <None>
      x630 <-> x512: LCA: Host, coarse-dist: <None>
      x765 <-> x512: LCA: Host, coarse-dist: <None>
      x616 <-> x512: LCA: Host, coarse-dist: <None>
      x531 <-> x512: LCA: Host, coarse-dist: <None>
      x612 <-> x512: LCA: Host, coarse-dist: <None>
      x528 <-> x512: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x616 = RegRead(x505) rd{0,0,0}
   c  modrd -> x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: ListBuffer(b50, b57, b69)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Leaf: x620, Iters: ListBuffer(b50, b57, b69), target: x809, elements: List(0, 0, 0)
    Current: x620
    Dephasing Iters: x765 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x787
    Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: ListBuffer(b50, b57, b69, b500)
    Current: x787
    Current: x801
    Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: List(0, 0, 0, 0)
    Current: x787
    Current: x801
    Leaf: x787, Iters: ListBuffer(b50, b57, b69, b500), target: x809, elements: List(0, 0, 0, 0)
    Current: x787
    Current: x801
    Dephasing Iters: x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: ListBuffer(b50, b57, b69, b491)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x708, Iters: ListBuffer(b50, b57, b69, b491), target: x809, elements: List(0, 0, 0, 0)
    Dephasing Iters: x612 = RegRead(x505) rd{0}
   c  modrd -> x807
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x807
    Current: x808
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x807
    Current: x808
    Leaf: x807, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x807
    Current: x808
    Dephasing Iters: x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: ListBuffer(b50, b57, b69, b482)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    Leaf: x651, Iters: ListBuffer(b50, b57, b69, b482), target: x809, elements: List(0, 0, 0, 0)
    General read dephasing rules for x505: (b50,List(0, 0, 0)) -> (b50,0)
  - (b500,List(0, 0, 0, 0)) -> (b500,0)
  - (b69,List(0, 0, 0, 0)) -> (b69,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b50,List(0)) -> (b50,0)
  - (b482,List(0, 0, 0, 0)) -> (b482,0)
  - (b491,List(0, 0, 0, 0)) -> (b491,0)
  - (b50,List(0, 0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x616 = RegRead(x505) rd{0,0,0}
   c  modrd, x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd, x765 = RegRead(x505) rd{0,0,0,0}
   c  modrd, x687 = RegRead(x505) rd{0,0,0,0}
   c  modrd, x612 = RegRead(x505) rd{0}
   c  modrd, x630 = RegRead(x505) rd{0,0,0,0}
   c  modrd), Set(), Set(x528 = RegRead(x505) rd{}
   c  modrd, x531 = RegRead(x505) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for N (x505)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 9 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 7 | 1 |
            - Duplicate costs 1.5773005310210393 (LUTs: 0.02046783625730994%, FFs: 0.001277139208173691%, BRAMs: 1.5555555555555556%)
    ***** Cost summary *****
    Cost: 1.5773005310210393 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x765 = RegRead(x505) rd{0,0,0,0}
        grp 0:    c  modrd
        grp 2: x616 = RegRead(x505) rd{0,0,0}
        grp 2:    c  modrd
        grp 2: x528 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x531 = RegRead(x505) rd{}
        grp 2:    c  modrd
        grp 2: x687 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 2: x612 = RegRead(x505) rd{0}
        grp 2:    c  modrd
        grp 2: x630 = RegRead(x505) rd{0,0,0,0}
        grp 2:    c  modrd
        grp 3: x528 = RegRead(x505) rd{}
        grp 3:    c  modrd
        grp 3: x531 = RegRead(x505) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x512 = SetReg(x505,x511) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x512 = SetReg(x505,x511) {}
      - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x708 (scope: 0, 0)
  [Ofs: 0] x630 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: x651 (scope: 0, 0)
  [Ofs: 0] x765 = RegRead(x505) {0,0,0,0}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: x787 (scope: 0, 0)
  [Ofs: 0] x616 = RegRead(x505) {0,0,0}
      - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
      - Scope: x620 (scope: 0, 0)
  [Ofs: 0] x612 = RegRead(x505) {0}
      - Lab2GEMM.scala:43:25: Foreach(N by tileN){nn =>
      - Scope: x807 (scope: -1, -1)
 - Mux Port #1: 
  [Ofs: 0] x528 = RegRead(x505) {}
      - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host
  [Ofs: 0] x531 = RegRead(x505) {}
      - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
      - Scope: Host))
  Result: Merged 3 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: N (x505)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:13:18
Src:      val N = ArgIn[Int]
Symbol:     x505 = ArgInNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    Buffer
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x512 = SetReg(x505,x511) {}
        - Lab2GEMM.scala:16:11: setArg(N,args(1).to[Int])
        - Scope: Host
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x687 = RegRead(x505) {0,0,0,0}
        - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
        - Scope: x708 (scope: 0, 0)
    [Ofs: 0] x630 = RegRead(x505) {0,0,0,0}
        - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
        - Scope: x651 (scope: 0, 0)
    [Ofs: 0] x765 = RegRead(x505) {0,0,0,0}
        - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
        - Scope: x787 (scope: 0, 0)
    [Ofs: 0] x616 = RegRead(x505) {0,0,0}
        - Lab2GEMM.scala:44:54: val numel_n = min(tileN.to[Int], N - nn)
        - Scope: x620 (scope: 0, 0)
    [Ofs: 0] x612 = RegRead(x505) {0}
        - Lab2GEMM.scala:43:25: Foreach(N by tileN){nn =>
        - Scope: x807 (scope: -1, -1)
   - Mux Port #1: 
    [Ofs: 0] x528 = RegRead(x505) {}
        - Lab2GEMM.scala:24:24: val b = DRAM[T](K, N) // input matrix 2
        - Scope: Host
    [Ofs: 0] x531 = RegRead(x505) {}
        - Lab2GEMM.scala:25:24: val c = DRAM[T](M, N) // an initial matrix for the result
        - Scope: Host



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(3)) to x616 {0,0,0}
  Added dispatch 0 to x616 {0,0,0}
  Added port Port(Some(0),1,0,List(0),List(0)) to x528 {}
  Added dispatch 0 to x528 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x531 {}
  Added dispatch 0 to x531 {}
  Added port Port(Some(0),0,0,List(0),List(2)) to x765 {0,0,0,0}
  Added dispatch 0 to x765 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x687 {0,0,0,0}
  Added dispatch 0 to x687 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(4)) to x612 {0}
  Added dispatch 0 to x612 {0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x630 {0,0,0,0}
  Added dispatch 0 to x630 {0,0,0,0}
  Added port Port(Some(0),1,0,List(0),List(0)) to x528 {}
  Added dispatch 0 to x528 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x531 {}
  Added dispatch 0 to x531 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x512 {}
  Added dispatch 0 to x512 {}
  Added port Port(Some(0),0,0,List(0),List(3)) to x616 {0,0,0}
  Added dispatch 0 to x616 {0,0,0}
  Added port Port(Some(0),1,0,List(0),List(0)) to x528 {}
  Added dispatch 0 to x528 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x531 {}
  Added dispatch 0 to x531 {}
  Added port Port(Some(0),0,0,List(0),List(2)) to x765 {0,0,0,0}
  Added dispatch 0 to x765 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x687 {0,0,0,0}
  Added dispatch 0 to x687 {0,0,0,0}
  Added port Port(Some(0),0,0,List(0),List(4)) to x612 {0}
  Added dispatch 0 to x612 {0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x630 {0,0,0,0}
  Added dispatch 0 to x630 {0,0,0,0}
  Added port Port(Some(0),1,0,List(0),List(0)) to x528 {}
  Added dispatch 0 to x528 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x531 {}
  Added dispatch 0 to x531 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x512 {}
  Added dispatch 0 to x512 {}
---------------------------------------------------------------------
INFERRING...
Name: x589
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x589 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x598 {} [x609 (stage: -1)]
  1 Read Groups:
  Group #0
    x598 = RegRead(x589) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x596 {} [x597 (stage: -1)]
  1 Write Groups:
  Group #0
    x596 = RegWrite(x589,x595,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x598 {}: 
      x596 {}
    x598 <-> x596: LCA: x610 (stage: -1), coarse-dist: <None>
    x596 <-> x596: LCA: x597 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x598 = RegRead(x589) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x610: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x597: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x596: RegWrite
    x609: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x598: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x589
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x598 = RegRead(x589) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x596 = RegWrite(x589,x595,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x596 = RegWrite(x589,x595,Set()) {}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x597 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x598 = RegRead(x589) {}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x609 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x589
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x589 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x596 = RegWrite(x589,x595,Set()) {}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x597 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x598 = RegRead(x589) {}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x609 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x598 {}
  Added dispatch 0 to x598 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x596 {}
  Added dispatch 0 to x596 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x598 {}
  Added dispatch 0 to x598 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x596 {}
  Added dispatch 0 to x596 {}
---------------------------------------------------------------------
INFERRING...
Name: x548
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:40:34
Src:                  val numel_m = min(tileM.to[Int], M - mm)(Pass 28)
Symbol:     x548 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 4 Reads: 
    Access: x555 {} [x583 (stage: -1)]
    Access: x680 {0} [x708 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
    Access: x737 {} [x754 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
Computing overlaps: x737 = Some(RegRead(x548)) - x680 = Some(RegRead(x548))
      Group #1 conflicts: <1 accesses>
      Group #1 same port: <1 accesses>
    Access: x755 {0} [x805 (stage: -1)]
      Group #0 conflicts: <none>
      Group #0 same port: <none> 
Computing overlaps: x755 = Some(RegRead(x548)) - x680 = Some(RegRead(x548))
Dephasing Iters: x755 = RegRead(x548) rd{0}
   c  modrd -> x805
Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
Current: x805
Current: x806
Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
Current: x805
Current: x806
Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
Current: x805
Current: x806
      Group #1 conflicts: <1 accesses>
      Group #1 same port: <1 accesses>
Computing overlaps: x755 = Some(RegRead(x548)) - x737 = Some(RegRead(x548))
      Group #2 conflicts: <1 accesses>
      Group #2 same port: <1 accesses>
  4 Read Groups:
  Group #0
    x555 = RegRead(x548) rd{}
       c  modrd
  Group #1
    x680 = RegRead(x548) rd{0}
       c  modrd
  Group #2
    x737 = RegRead(x548) rd{}
       c  modrd
  Group #3
    x755 = RegRead(x548) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x552 {} [x553 (stage: -1)]
  1 Write Groups:
  Group #0
    x552 = RegWrite(x548,x551,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x555 {}: 
      x552 {}
    x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
    x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
  x555 <-> x552 # LCA: x808 (stage: -1), Dist: Some(1)
  x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x555 = RegRead(x548) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x552: RegWrite
    x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
      x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
        x555: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x548
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x555 = RegRead(x548) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x555 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x583 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x680 {0}: 
      x552 {}
    x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
    x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
  x680 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
  x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
  Dephasing Iters: x680 = RegRead(x548) rd{0}
   c  modrd -> x708
  Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
  Current: x708
  Current: x736
  Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
  Current: x708
  Current: x736
  Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
  Current: x708
  Current: x736
  General read dephasing rules for x548: (b69,List(0)) -> (b69,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x680 = RegRead(x548) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x552: RegWrite
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x680: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x548
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x680 = RegRead(x548) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x680 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x708 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x680 = Some(RegRead(x548)) - x555 = Some(RegRead(x548))
    Computing overlaps: x552 = Some(RegWrite(x548,x551,Set())) - x552 = Some(RegWrite(x548,x551,Set()))
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
      Preceding writes for x680 {0}: 
        x552 {}
      Preceding writes for x555 {}: 
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
    x680 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    x555 <-> x552 # LCA: x808 (stage: -1), Dist: Some(1)
    x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
    Dephasing Iters: x680 = RegRead(x548) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    General read dephasing rules for x548: (b69,List(0)) -> (b69,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x680 = RegRead(x548) rd{0}
   c  modrd, x555 = RegRead(x548) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x552: RegWrite
      x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x555: RegRead
      x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x680: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x548
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 1.3519718837323191 (LUTs: 0.017543859649122806%, FFs: 0.0010946907498631637%, BRAMs: 1.3333333333333333%)
    ***** Cost summary *****
    Cost: 1.3519718837323191 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x680 = RegRead(x548) rd{0}
        grp 0:    c  modrd
        grp 2: x555 = RegRead(x548) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x555 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x583 (scope: -1, -1)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x680 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x708 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 1 into instance 0
Group #2: 
    Preceding writes for x737 {}: 
      x552 {}
    x737 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
    x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
  x737 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
  x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x737 = RegRead(x548) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x552: RegWrite
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
  **************************************************************************************
  Analyzing costs for banking schemes found for x548
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x737 = RegRead(x548) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x737 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x754 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x737 = Some(RegRead(x548)) - x680 = Some(RegRead(x548))
    Computing overlaps: x737 = Some(RegRead(x548)) - x555 = Some(RegRead(x548))
    Computing overlaps: x552 = Some(RegWrite(x548,x551,Set())) - x552 = Some(RegWrite(x548,x551,Set()))
      x737 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
      Preceding writes for x737 {}: 
        x552 {}
      Preceding writes for x680 {0}: 
      Preceding writes for x555 {}: 
      x737 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
    x737 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    x680 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    x555 <-> x552 # LCA: x808 (stage: -1), Dist: Some(1)
    x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
    Dephasing Iters: x680 = RegRead(x548) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    General read dephasing rules for x548: (b69,List(0)) -> (b69,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x737 = RegRead(x548) rd{}
   c  modrd, x680 = RegRead(x548) rd{0}
   c  modrd, x555 = RegRead(x548) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x552: RegWrite
      x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x555: RegRead
      x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x680: RegRead
        x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    **************************************************************************************
    Analyzing costs for banking schemes found for x548
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 3 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 2.027957825598479 (LUTs: 0.02631578947368421%, FFs: 0.0016420361247947454%, BRAMs: 2.0%)
    ***** Cost summary *****
    Cost: 2.027957825598479 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x737 = RegRead(x548) rd{}
        grp 0:    c  modrd
        grp 2: x680 = RegRead(x548) rd{0}
        grp 2:    c  modrd
        grp 2: x555 = RegRead(x548) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x555 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x583 (scope: -1, -1)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x737 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x754 (scope: -1, -1)
  [Ofs: 1] x680 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x708 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 2 into instance 0
Group #3: 
    Preceding writes for x755 {0}: 
      x552 {}
    x755 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
    x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
  x755 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
  x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
  Dephasing Iters: x755 = RegRead(x548) rd{0}
   c  modrd -> x805
  Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
  Current: x805
  Current: x806
  Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
  Current: x805
  Current: x806
  Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
  Current: x805
  Current: x806
  General read dephasing rules for x548: (b69,List(0)) -> (b69,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x755 = RegRead(x548) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x552: RegWrite
    x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x806: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x805: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
  **************************************************************************************
  Analyzing costs for banking schemes found for x548
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
  ***** Cost summary *****
  Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x755 = RegRead(x548) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x755 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x805 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #3 with instance #0: 
    Computing overlaps: x755 = Some(RegRead(x548)) - x737 = Some(RegRead(x548))
    Computing overlaps: x755 = Some(RegRead(x548)) - x680 = Some(RegRead(x548))
    Dephasing Iters: x755 = RegRead(x548) rd{0}
   c  modrd -> x805
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
    Current: x805
    Current: x806
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x805
    Current: x806
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x805
    Current: x806
    Computing overlaps: x755 = Some(RegRead(x548)) - x555 = Some(RegRead(x548))
    Computing overlaps: x552 = Some(RegWrite(x548,x551,Set())) - x552 = Some(RegWrite(x548,x551,Set()))
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x737 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x755 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      Preceding writes for x755 {0}: 
        x552 {}
      Preceding writes for x737 {}: 
      Preceding writes for x680 {0}: 
      Preceding writes for x555 {}: 
      x555 <-> x552: LCA: x808 (stage: -1), coarse-dist: 1
      x737 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x552 <-> x552: LCA: x553 (stage: -1), coarse-dist: <None>
      x680 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
      x755 <-> x552: LCA: x808 (stage: -1), coarse-dist: 2
    x555 <-> x552 # LCA: x808 (stage: -1), Dist: Some(1)
    x737 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    x552 <-> x552 # LCA: x808 (stage: -1), Dist: Some(0)
    x680 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    x755 <-> x552 # LCA: x808 (stage: -1), Dist: Some(2)
    Dephasing Iters: x755 = RegRead(x548) rd{0}
   c  modrd -> x805
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
    Current: x805
    Current: x806
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x805
    Current: x806
    Leaf: x805, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x805
    Current: x806
    Dephasing Iters: x680 = RegRead(x548) rd{0}
   c  modrd -> x708
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: ListBuffer(b69)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    Leaf: x708, Iters: ListBuffer(b69), target: x807, elements: List(0)
    Current: x708
    Current: x736
    General read dephasing rules for x548: (b69,List(0)) -> (b69,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x755 = RegRead(x548) rd{0}
   c  modrd, x737 = RegRead(x548) rd{}
   c  modrd, x680 = RegRead(x548) rd{0}
   c  modrd, x555 = RegRead(x548) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x553: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x552: RegWrite
      x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x555: RegRead
      x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x736: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x708: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x680: RegRead
        x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
        x806: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x805: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    **************************************************************************************
    Analyzing costs for banking schemes found for x548
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 4 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 4 | 1 |
            - Duplicate costs 2.7039437674646383 (LUTs: 0.03508771929824561%, FFs: 0.0021893814997263274%, BRAMs: 2.6666666666666665%)
    ***** Cost summary *****
    Cost: 2.7039437674646383 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x755 = RegRead(x548) rd{0}
        grp 0:    c  modrd
        grp 2: x737 = RegRead(x548) rd{}
        grp 2:    c  modrd
        grp 2: x680 = RegRead(x548) rd{0}
        grp 2:    c  modrd
        grp 2: x555 = RegRead(x548) rd{}
        grp 2:    c  modrd
      Writes:
        grp 0: x552 = RegWrite(x548,x551,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    3
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x808 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x553 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x555 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x583 (scope: -1, -1)
2 [Type:WR]:
2 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x737 = RegRead(x548) {}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x754 (scope: -1, -1)
  [Ofs: 1] x755 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x805 (scope: -1, -1)
  [Ofs: 2] x680 = RegRead(x548) {0}
      - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
      - Scope: x708 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 3 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: x548
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:40:34
Src:                  val numel_m = min(tileM.to[Int], M - mm)(Pass 28)
Symbol:     x548 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    3
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: x808 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x552 = RegWrite(x548,x551,Set()) {}
        - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
        - Scope: x553 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x555 = RegRead(x548) {}
        - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
        - Scope: x583 (scope: -1, -1)
  2 [Type:WR]:
  2 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x737 = RegRead(x548) {}
        - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
        - Scope: x754 (scope: -1, -1)
    [Ofs: 1] x755 = RegRead(x548) {0}
        - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
        - Scope: x805 (scope: -1, -1)
    [Ofs: 2] x680 = RegRead(x548) {0}
        - Lab2GEMM.scala:40:34: val numel_m = min(tileM.to[Int], M - mm)(Pass 28)(Pass 28)
        - Scope: x708 (scope: -1, -1)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(2),0,1,List(1),List(0)) to x755 {0}
  Added dispatch 0 to x755 {0}
  Added port Port(Some(2),0,0,List(0),List(0)) to x737 {}
  Added dispatch 0 to x737 {}
  Added port Port(Some(2),0,2,List(2),List(0)) to x680 {0}
  Added dispatch 0 to x680 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x555 {}
  Added dispatch 0 to x555 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x552 {}
  Added dispatch 0 to x552 {}
  Added port Port(Some(2),0,1,List(1),List(0)) to x755 {0}
  Added dispatch 0 to x755 {0}
  Added port Port(Some(2),0,0,List(0),List(0)) to x737 {}
  Added dispatch 0 to x737 {}
  Added port Port(Some(2),0,2,List(2),List(0)) to x680 {0}
  Added dispatch 0 to x680 {0}
  Added port Port(Some(1),0,0,List(0),List(0)) to x555 {}
  Added dispatch 0 to x555 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x552 {}
  Added dispatch 0 to x552 {}
---------------------------------------------------------------------
INFERRING...
Name: x712
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x712 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x726 {0} [x734 (stage: -1)]
  1 Read Groups:
  Group #0
    x726 = RegRead(x712) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x717 {} [x722 (stage: -1)]
  1 Write Groups:
  Group #0
    x717 = RegWrite(x712,x716,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x726 {0}: 
      x717 {}
    x726 <-> x717: LCA: x735 (stage: -1), coarse-dist: <None>
    x717 <-> x717: LCA: x722 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x726 = RegRead(x712) rd{0}
   c  modrd -> x734
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: ListBuffer(b352)
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: List(0)
  Leaf: x734, Iters: ListBuffer(b352), target: x734, elements: List(0)
  General read dephasing rules for x712: (b352,List(0)) -> (b352,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x726 = RegRead(x712) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x735: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x722: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x717: RegWrite
    x734: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x726: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x712
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x726 = RegRead(x712) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x717 = RegWrite(x712,x716,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x717 = RegWrite(x712,x716,Set()) {}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x722 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x726 = RegRead(x712) {0}
      - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x734 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x712
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:48:32
Src:                      tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x712 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x717 = RegWrite(x712,x716,Set()) {}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x722 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x726 = RegRead(x712) {0}
        - Lab2GEMM.scala:48:32: tileC_sram load c(mm::mm+numel_m, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x734 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x726 {0}
  Added dispatch 0 to x726 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x717 {}
  Added dispatch 0 to x717 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x726 {0}
  Added dispatch 0 to x726 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x717 {}
  Added dispatch 0 to x717 {}
---------------------------------------------------------------------
INFERRING...
Name: x557
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x557 = FIFONew(Const(16))
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x590 {0} [x597 (stage: -1)]
  1 Read Groups:
  Group #0
    x590 = FIFODeq(x557,Set(Const(true))) rd{0}
     b477     c   mod
        1     0     0rd
  Grouping 1 Writes: 
    Access: x582 {0} [x583 (stage: -1)]
  1 Write Groups:
  Group #0
    x582 = FIFOEnq(x557,x581,Set(Const(true))) wr{0}
     b473     c   mod
        1     0     0wr



Merging memory instance groups:
Group #0: 
  Dephasing Iters: x590 = FIFODeq(x557,Set(Const(true))) rd{0}
 b477     c   mod
    1     0     0rd -> x597
  Leaf: x597, Iters: ListBuffer(b477), target: x610, elements: ListBuffer(b477)
  Current: x597
  Leaf: x597, Iters: ListBuffer(b477), target: x610, elements: List(0)
  Current: x597
  Leaf: x597, Iters: ListBuffer(b477), target: x610, elements: List(0)
  Current: x597
  General read dephasing rules for x557: (b477,List(0)) -> (b477,0)
  Dephasing Iters: x582 = FIFOEnq(x557,x581,Set(Const(true))) wr{0}
 b473     c   mod
    1     0     0wr -> x583
  Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: ListBuffer(b473)
  Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: List(0)
  Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: List(0)
  General write dephasing rules for x557: (b473,List(0)) -> (b473,0)
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 3.605258356619518 (LUTs: 0.04678362573099415%, FFs: 0.0029191753329684362%, BRAMs: 3.5555555555555554%)
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x557
Type: FIFO[IssuedCmd]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x557 = FIFONew(Const(16))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x582 = FIFOEnq(x557,x581,Set(Const(true))) {0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x583 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x590 = FIFODeq(x557,Set(Const(true))) {0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x597 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x590 {0}
  Added dispatch 0 to x590 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x582 {0}
  Added dispatch 0 to x582 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x590 {0}
  Added dispatch 0 to x590 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x582 {0}
  Added dispatch 0 to x582 {0}
---------------------------------------------------------------------
INFERRING...
Name: x656
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x656 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x671 {0} [x677 (stage: -1)]
  1 Read Groups:
  Group #0
    x671 = RegRead(x656) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x662 {} [x665 (stage: -1)]
  1 Write Groups:
  Group #0
    x662 = RegWrite(x656,x661,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x671 {0}: 
      x662 {}
    x671 <-> x662: LCA: x678 (stage: -1), coarse-dist: <None>
    x662 <-> x662: LCA: x665 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x671 = RegRead(x656) rd{0}
   c  modrd -> x677
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: ListBuffer(b289)
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: List(0)
  Leaf: x677, Iters: ListBuffer(b289), target: x677, elements: List(0)
  General read dephasing rules for x656: (b289,List(0)) -> (b289,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x671 = RegRead(x656) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x678: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x665: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x662: RegWrite
    x677: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x671: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x656
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x671 = RegRead(x656) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x662 = RegWrite(x656,x661,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x662 = RegWrite(x656,x661,Set()) {}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x665 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x671 = RegRead(x656) {0}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x677 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x656
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x656 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x662 = RegWrite(x656,x661,Set()) {}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x665 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x671 = RegRead(x656) {0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x677 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x671 {0}
  Added dispatch 0 to x671 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x662 {}
  Added dispatch 0 to x662 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x671 {0}
  Added dispatch 0 to x671 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x662 {}
  Added dispatch 0 to x662 {}
---------------------------------------------------------------------
INFERRING...
Name: x556
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x556 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x580 {0} [x583 (stage: -1)]
  1 Write Groups:
  Group #0
    x580 = StreamOutWrite(x556,x578,Set(x579)) wr{0}
     b473     c   mod
        1     0     0wr
  x580 <-> x580: LCA: x583 (stage: -1), coarse-dist: <None>
Dephasing Iters: x580 = StreamOutWrite(x556,x578,Set(x579)) wr{0}
 b473     c   mod
    1     0     0wr -> x583
Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: ListBuffer(b473)
Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: List(0)
Leaf: x583, Iters: ListBuffer(b473), target: x583, elements: List(0)
General write dephasing rules for x556: (b473,List(0)) -> (b473,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
  x580: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x556
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x580 = StreamOutWrite(x556,x578,Set(x579)) wr{0}
    grp 0:  b473     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x580 = StreamOutWrite(x556,x578,Set(x579)) {0}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x583 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x556
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x556 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x580 = StreamOutWrite(x556,x578,Set(x579)) {0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x583 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x580 {0}
  Added dispatch 0 to x580 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x580 {0}
  Added dispatch 0 to x580 {0}
---------------------------------------------------------------------
INFERRING...
Name: x539
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:38:30
Src:              val numel_k = min(tileK.to[Int], K - kk)(Pass 28)
Symbol:     x539 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 3 Reads: 
    Access: x569 {0,0} [x583 (stage: -1)]
    Access: x623 {0,0} [x651 (stage: -1)]
Computing overlaps: x623 = Some(RegRead(x539)) - x569 = Some(RegRead(x539))
      Group #0 conflicts: <1 accesses>
      Group #0 same port: <1 accesses>
    Access: x743 {0,0,0} [x752 (stage: -1)]
Computing overlaps: x743 = Some(RegRead(x539)) - x569 = Some(RegRead(x539))
      Group #0 conflicts: <1 accesses>
      Group #0 same port: <1 accesses>
Computing overlaps: x743 = Some(RegRead(x539)) - x623 = Some(RegRead(x539))
      Group #1 conflicts: <1 accesses>
      Group #1 same port: <1 accesses>
  3 Read Groups:
  Group #0
    x569 = RegRead(x539) rd{0,0}
       c  modrd
  Group #1
    x623 = RegRead(x539) rd{0,0}
       c  modrd
  Group #2
    x743 = RegRead(x539) rd{0,0,0}
       c  modrd
  Grouping 1 Writes: 
    Access: x543 {} [x544 (stage: -1)]
  1 Write Groups:
  Group #0
    x543 = RegWrite(x539,x542,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x569 {0,0}: 
      x543 {}
    x569 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
    x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
  x569 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
  x543 <-> x543 # LCA: x809 (stage: -1), Dist: Some(0)
  Dephasing Iters: x569 = RegRead(x539) rd{0,0}
   c  modrd -> x583
  Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: ListBuffer(b57, b473)
  Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
  Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
  General read dephasing rules for x539: (b57,List(0, 0)) -> (b57,0)
  - (b473,List(0, 0)) -> (b473,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x569 = RegRead(x539) rd{0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x809: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x544: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x543: RegWrite
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
        x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
          x569: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x539
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x569 = RegRead(x539) rd{0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x543 = RegWrite(x539,x542,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x809 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x544 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x569 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x583 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Created instance #0
Group #1: 
    Preceding writes for x623 {0,0}: 
      x543 {}
    x623 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
    x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
  x623 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
  x543 <-> x543 # LCA: x809 (stage: -1), Dist: Some(0)
  Dephasing Iters: x623 = RegRead(x539) rd{0,0}
   c  modrd -> x651
  Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: ListBuffer(b57, b69)
  Current: x651
  Current: x679
  Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
  Current: x651
  Current: x679
  Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
  Current: x651
  Current: x679
  General read dephasing rules for x539: (b57,List(0, 0)) -> (b57,0)
  - (b69,List(0, 0)) -> (b69,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x623 = RegRead(x539) rd{0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x809: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x544: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x543: RegWrite
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x623: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x539
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x623 = RegRead(x539) rd{0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x543 = RegWrite(x539,x542,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x809 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x544 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x623 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x651 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x623 = Some(RegRead(x539)) - x569 = Some(RegRead(x539))
    Computing overlaps: x543 = Some(RegWrite(x539,x542,Set())) - x543 = Some(RegWrite(x539,x542,Set()))
      x623 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x569 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
      Preceding writes for x623 {0,0}: 
        x543 {}
      Preceding writes for x569 {0,0}: 
      x623 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x569 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
    x623 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
    x569 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
    x543 <-> x543 # LCA: x809 (stage: -1), Dist: Some(0)
    Dephasing Iters: x623 = RegRead(x539) rd{0,0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: ListBuffer(b57, b69)
    Current: x651
    Current: x679
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
    Current: x651
    Current: x679
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
    Current: x651
    Current: x679
    Dephasing Iters: x569 = RegRead(x539) rd{0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: ListBuffer(b57, b473)
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
    General read dephasing rules for x539: (b57,List(0, 0)) -> (b57,0)
  - (b69,List(0, 0)) -> (b69,0)
  - (b473,List(0, 0)) -> (b473,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x623 = RegRead(x539) rd{0,0}
   c  modrd, x569 = RegRead(x539) rd{0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x809: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x544: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x543: RegWrite
      x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x569: RegRead
        x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
          x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
            x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
              x623: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x539
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
    ***** Cost summary *****
    Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x623 = RegRead(x539) rd{0,0}
        grp 0:    c  modrd
        grp 2: x569 = RegRead(x539) rd{0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x543 = RegWrite(x539,x542,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x809 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x544 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x623 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x651 (scope: -1, -1)
  [Ofs: 1] x569 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x583 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 1 into instance 0
Group #2: 
    Preceding writes for x743 {0,0,0}: 
      x543 {}
    x743 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
    x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
  x743 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
  x543 <-> x543 # LCA: x809 (stage: -1), Dist: Some(0)
  Dephasing Iters: x743 = RegRead(x539) rd{0,0,0}
   c  modrd -> x752
  Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: ListBuffer(b57, b69, b84)
  Current: x752
  Current: x753
  Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: List(0, 0, 0)
  Current: x752
  Current: x753
  Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: List(0, 0, 0)
  Current: x752
  Current: x753
  General read dephasing rules for x539: (b57,List(0, 0, 0)) -> (b57,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b84,List(0, 0, 0)) -> (b84,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x743 = RegRead(x539) rd{0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x809: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
    x544: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x543: RegWrite
    x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
          x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
            x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
              x743: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x539
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
  ***** Cost summary *****
  Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x743 = RegRead(x539) rd{0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x543 = RegWrite(x539,x542,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x809 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x544 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x743 = RegRead(x539) {0,0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x752 (scope: -1, -1)
M [Type:WR]:
M [Type:RD]:))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x743 = Some(RegRead(x539)) - x623 = Some(RegRead(x539))
    Computing overlaps: x743 = Some(RegRead(x539)) - x569 = Some(RegRead(x539))
    Computing overlaps: x543 = Some(RegWrite(x539,x542,Set())) - x543 = Some(RegWrite(x539,x542,Set()))
      x743 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x623 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x569 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
      Preceding writes for x743 {0,0,0}: 
        x543 {}
      Preceding writes for x623 {0,0}: 
      Preceding writes for x569 {0,0}: 
      x743 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x623 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x569 <-> x543: LCA: x809 (stage: -1), coarse-dist: 1
      x543 <-> x543: LCA: x544 (stage: -1), coarse-dist: <None>
    x743 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
    x623 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
    x569 <-> x543 # LCA: x809 (stage: -1), Dist: Some(1)
    x543 <-> x543 # LCA: x809 (stage: -1), Dist: Some(0)
    Dephasing Iters: x743 = RegRead(x539) rd{0,0,0}
   c  modrd -> x752
    Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: ListBuffer(b57, b69, b84)
    Current: x752
    Current: x753
    Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: List(0, 0, 0)
    Current: x752
    Current: x753
    Leaf: x752, Iters: ListBuffer(b57, b69, b84), target: x808, elements: List(0, 0, 0)
    Current: x752
    Current: x753
    Dephasing Iters: x623 = RegRead(x539) rd{0,0}
   c  modrd -> x651
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: ListBuffer(b57, b69)
    Current: x651
    Current: x679
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
    Current: x651
    Current: x679
    Leaf: x651, Iters: ListBuffer(b57, b69), target: x808, elements: List(0, 0)
    Current: x651
    Current: x679
    Dephasing Iters: x569 = RegRead(x539) rd{0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: ListBuffer(b57, b473)
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
    Leaf: x583, Iters: ListBuffer(b57, b473), target: x808, elements: List(0, 0)
    General read dephasing rules for x539: (b473,List(0, 0)) -> (b473,0)
  - (b69,List(0, 0)) -> (b69,0)
  - (b84,List(0, 0, 0)) -> (b84,0)
  - (b69,List(0, 0, 0)) -> (b69,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b57,List(0, 0)) -> (b57,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x743 = RegRead(x539) rd{0,0,0}
   c  modrd, x623 = RegRead(x539) rd{0,0}
   c  modrd, x569 = RegRead(x539) rd{0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    x809: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
      x544: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
        x543: RegWrite
      x808: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
        x611: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
          x583: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
            x569: RegRead
        x807: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Pipelined]
          x679: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Streaming]
            x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
              x623: RegRead
          x754: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
            x753: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
              x752: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
                x743: RegRead
    **************************************************************************************
    Analyzing costs for banking schemes found for x539
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 3 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 1.3519718837323191 (LUTs: 0.017543859649122806%, FFs: 0.0010946907498631637%, BRAMs: 1.3333333333333333%)
    ***** Cost summary *****
    Cost: 1.3519718837323191 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x743 = RegRead(x539) rd{0,0,0}
        grp 0:    c  modrd
        grp 2: x623 = RegRead(x539) rd{0,0}
        grp 2:    c  modrd
        grp 2: x569 = RegRead(x539) rd{0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x543 = RegWrite(x539,x542,Set()) wr{}
        grp 0:    c  mod
        grp 0:    0    0wr
      Result: Right(List(<Banked>
Depth:    2
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: x809 (stage: -1)
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x544 (scope: 0, 0)
0 [Type:RD]:
1 [Type:WR]:
1 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x743 = RegRead(x539) {0,0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x752 (scope: -1, -1)
  [Ofs: 1] x623 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x651 (scope: -1, -1)
  [Ofs: 2] x569 = RegRead(x539) {0,0}
      - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
      - Scope: x583 (scope: 0, 0)
M [Type:WR]:
M [Type:RD]:))
  Result: Merged 2 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: x539
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:38:30
Src:              val numel_k = min(tileK.to[Int], K - kk)(Pass 28)
Symbol:     x539 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    2
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: x809 (stage: -1)
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x543 = RegWrite(x539,x542,Set()) {}
        - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
        - Scope: x544 (scope: 0, 0)
  0 [Type:RD]:
  1 [Type:WR]:
  1 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x743 = RegRead(x539) {0,0,0}
        - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
        - Scope: x752 (scope: -1, -1)
    [Ofs: 1] x623 = RegRead(x539) {0,0}
        - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
        - Scope: x651 (scope: -1, -1)
    [Ofs: 2] x569 = RegRead(x539) {0,0}
        - Lab2GEMM.scala:38:30: val numel_k = min(tileK.to[Int], K - kk)(Pass 28)(Pass 28)
        - Scope: x583 (scope: 0, 0)
  M [Type:WR]:
  M [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(1),0,0,List(0),List(0)) to x743 {0,0,0}
  Added dispatch 0 to x743 {0,0,0}
  Added port Port(Some(1),0,1,List(1),List(0)) to x623 {0,0}
  Added dispatch 0 to x623 {0,0}
  Added port Port(Some(1),0,2,List(2),List(0)) to x569 {0,0}
  Added dispatch 0 to x569 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x543 {}
  Added dispatch 0 to x543 {}
  Added port Port(Some(1),0,0,List(0),List(0)) to x743 {0,0,0}
  Added dispatch 0 to x743 {0,0,0}
  Added port Port(Some(1),0,1,List(1),List(0)) to x623 {0,0}
  Added dispatch 0 to x623 {0,0}
  Added port Port(Some(1),0,2,List(2),List(0)) to x569 {0,0}
  Added dispatch 0 to x569 {0,0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x543 {}
  Added dispatch 0 to x543 {}
---------------------------------------------------------------------
INFERRING...
Name: x588
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x588 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x603 {0} [x609 (stage: -1)]
  1 Read Groups:
  Group #0
    x603 = RegRead(x588) rd{0}
       c  modrd
  Grouping 1 Writes: 
    Access: x594 {} [x597 (stage: -1)]
  1 Write Groups:
  Group #0
    x594 = RegWrite(x588,x593,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x603 {0}: 
      x594 {}
    x603 <-> x594: LCA: x610 (stage: -1), coarse-dist: <None>
    x594 <-> x594: LCA: x597 (stage: -1), coarse-dist: <None>
  Dephasing Iters: x603 = RegRead(x588) rd{0}
   c  modrd -> x609
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: ListBuffer(b223)
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: List(0)
  Leaf: x609, Iters: ListBuffer(b223), target: x609, elements: List(0)
  General read dephasing rules for x588: (b223,List(0)) -> (b223,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x603 = RegRead(x588) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x610: OpForeach (-1) [Level: OuterControl, Loop: Looped, Schedule: Sequenced]
    x597: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x594: RegWrite
    x609: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x603: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x588
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x603 = RegRead(x588) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x594 = RegWrite(x588,x593,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x594 = RegWrite(x588,x593,Set()) {}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x597 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x603 = RegRead(x588) {0}
      - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
      - Scope: x609 (scope: 0, 0)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x588
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:42:28
Src:                  tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
Symbol:     x588 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x594 = RegWrite(x588,x593,Set()) {}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x597 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x603 = RegRead(x588) {0}
        - Lab2GEMM.scala:42:28: tileA_sram load a(mm::mm+numel_m, kk::kk+numel_k)
        - Scope: x609 (scope: 0, 0)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x603 {0}
  Added dispatch 0 to x603 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x594 {}
  Added dispatch 0 to x594 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x603 {0}
  Added dispatch 0 to x603 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x594 {}
  Added dispatch 0 to x594 {}
---------------------------------------------------------------------
INFERRING...
Name: x763
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x763 = RegNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 1 Reads: 
    Access: x788 {} [x800 (stage: -1)]
  1 Read Groups:
  Group #0
    x788 = RegRead(x763) rd{}
       c  modrd
  Grouping 1 Writes: 
    Access: x786 {} [x787 (stage: -1)]
  1 Write Groups:
  Group #0
    x786 = RegWrite(x763,x776,Set()) wr{}
       c  mod
       0    0wr



Merging memory instance groups:
Group #0: 
    Preceding writes for x788 {}: 
      x786 {}
    x788 <-> x786: LCA: x801 (stage: -1), coarse-dist: <None>
    x786 <-> x786: LCA: x787 (stage: -1), coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x788 = RegRead(x763) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  x801: UnitPipe (-1) [Level: OuterControl, Loop: Single, Schedule: Sequenced]
    x787: UnitPipe (-1) [Level: InnerControl, Loop: Single, Schedule: Sequenced]
      x786: RegWrite
    x800: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Pipelined]
      x788: RegRead
  **************************************************************************************
  Analyzing costs for banking schemes found for x763
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x788 = RegRead(x763) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x786 = RegWrite(x763,x776,Set()) wr{}
      grp 0:    c  mod
      grp 0:    0    0wr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x786 = RegWrite(x763,x776,Set()) {}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x787 (scope: 0, 0)
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x788 = RegRead(x763) {}
      - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
      - Scope: x800 (scope: -1, -1)))
  Result: Created instance #0
---------------------------------------------------------------------
SUMMARY: 
Name: x763
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:58:55
Src:                      c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
Symbol:     x763 = RegNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    None
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x786 = RegWrite(x763,x776,Set()) {}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x787 (scope: 0, 0)
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x788 = RegRead(x763) {}
        - Lab2GEMM.scala:58:55: c(mm::mm+numel_m, nn::nn+numel_n) store tileC_sram // SRAM -> DRAM
        - Scope: x800 (scope: -1, -1)



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x788 {}
  Added dispatch 0 to x788 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x786 {}
  Added dispatch 0 to x786 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x788 {}
  Added dispatch 0 to x788 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x786 {}
  Added dispatch 0 to x786 {}
---------------------------------------------------------------------
INFERRING...
Name: K (x506)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:14:18
Src:      val K = ArgIn[Int]
Symbol:     x506 = ArgInNew(Const(0))
Effort:    1
BankingViews:   List(Hierarchical(0,None))
NStrictness:   List(NRelaxed)
AlphaStrictness:   List(AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 5 Reads: 
    Access: x525 {} [Host]
    Access: x527 {} [Host]
    Access: x536 {} [x809 (stage: -1)]
    Access: x540 {0} [x544 (stage: -1)]
    Access: x562 {0,0,0} [x583 (stage: -1)]
  5 Read Groups:
  Group #0
    x525 = RegRead(x506) rd{}
       c  modrd
  Group #1
    x527 = RegRead(x506) rd{}
       c  modrd
  Group #2
    x536 = RegRead(x506) rd{}
       c  modrd
  Group #3
    x540 = RegRead(x506) rd{0}
       c  modrd
  Group #4
    x562 = RegRead(x506) rd{0,0,0}
       c  modrd
  Grouping 1 Writes: 
    Access: x515 {} [Host]
  1 Write Groups:
  Group #0
    x515 = SetReg(x506,x514) wr{}
       c  modwr



Merging memory instance groups:
Group #4: 
    x562 <-> x515: LCA: Host, coarse-dist: <None>
    x515 <-> x515: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x562 = RegRead(x506) rd{0,0,0}
   c  modrd -> x583
  Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: ListBuffer(b50, b57, b473)
  Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
  Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
  General read dephasing rules for x506: (b50,List(0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b473,List(0, 0, 0)) -> (b473,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x562 = RegRead(x506) rd{0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for K (x506)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x562 = RegRead(x506) rd{0,0,0}
      grp 0:    c  modrd
    Writes:
      grp 0: x515 = SetReg(x506,x514) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x562 = RegRead(x506) {0,0,0}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: x583 (scope: 0, 0)))
  Result: Created instance #0
Group #2: 
    x540 <-> x515: LCA: Host, coarse-dist: <None>
    x515 <-> x515: LCA: Host, coarse-dist: <None>
  Dephasing Iters: x540 = RegRead(x506) rd{0}
   c  modrd -> x544
  Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
  Current: x544
  Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
  Current: x544
  Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
  Current: x544
  General read dephasing rules for x506: (b50,List(0)) -> (b50,0)
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x540 = RegRead(x506) rd{0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for K (x506)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x540 = RegRead(x506) rd{0}
      grp 0:    c  modrd
    Writes:
      grp 0: x515 = SetReg(x506,x514) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x540 = RegRead(x506) {0}
      - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
      - Scope: x544 (scope: 0, 0)))
  Attempting to merge group #2 with instance #0: 
    Computing overlaps: x540 = Some(RegRead(x506)) - x562 = Some(RegRead(x506))
    Computing overlaps: x515 = Some(SetReg(x506,x514)) - x515 = Some(SetReg(x506,x514))
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x540 = RegRead(x506) rd{0}
   c  modrd -> x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Dephasing Iters: x562 = RegRead(x506) rd{0,0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: ListBuffer(b50, b57, b473)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    General read dephasing rules for x506: (b50,List(0)) -> (b50,0)
  - (b50,List(0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b473,List(0, 0, 0)) -> (b473,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x540 = RegRead(x506) rd{0}
   c  modrd, x562 = RegRead(x506) rd{0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for K (x506)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 2 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 2 | 1 |
            - Duplicate costs 0.45065729457743975 (LUTs: 0.005847953216374269%, FFs: 3.6489691662105453E-4%, BRAMs: 0.4444444444444444%)
    ***** Cost summary *****
    Cost: 0.45065729457743975 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x540 = RegRead(x506) rd{0}
        grp 0:    c  modrd
        grp 2: x562 = RegRead(x506) rd{0,0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x515 = SetReg(x506,x514) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x540 = RegRead(x506) {0}
      - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
      - Scope: x544 (scope: 0, 0)
  [Ofs: 0] x562 = RegRead(x506) {0,0,0}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: x583 (scope: 0, 0)))
  Result: Merged 2 into instance 0
Group #3: 
    x536 <-> x515: LCA: Host, coarse-dist: <None>
    x515 <-> x515: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x536 = RegRead(x506) rd{}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for K (x506)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x536 = RegRead(x506) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x515 = SetReg(x506,x514) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x536 = RegRead(x506) {}
      - Lab2GEMM.scala:37:17: Foreach(K by tileK){kk =>
      - Scope: x809 (scope: -1, -1)))
  Attempting to merge group #3 with instance #0: 
    Computing overlaps: x536 = Some(RegRead(x506)) - x540 = Some(RegRead(x506))
    Computing overlaps: x536 = Some(RegRead(x506)) - x562 = Some(RegRead(x506))
    Computing overlaps: x515 = Some(SetReg(x506,x514)) - x515 = Some(SetReg(x506,x514))
      x536 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x536 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x540 = RegRead(x506) rd{0}
   c  modrd -> x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Dephasing Iters: x562 = RegRead(x506) rd{0,0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: ListBuffer(b50, b57, b473)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    General read dephasing rules for x506: (b50,List(0)) -> (b50,0)
  - (b50,List(0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b473,List(0, 0, 0)) -> (b473,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(x536 = RegRead(x506) rd{}
   c  modrd, x540 = RegRead(x506) rd{0}
   c  modrd, x562 = RegRead(x506) rd{0,0,0}
   c  modrd), Set()) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for K (x506)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 3 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 3 | 1 |
            - Duplicate costs 0.6759859418661596 (LUTs: 0.008771929824561403%, FFs: 5.473453749315818E-4%, BRAMs: 0.6666666666666666%)
    ***** Cost summary *****
    Cost: 0.6759859418661596 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 0: x536 = RegRead(x506) rd{}
        grp 0:    c  modrd
        grp 2: x540 = RegRead(x506) rd{0}
        grp 2:    c  modrd
        grp 2: x562 = RegRead(x506) rd{0,0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x515 = SetReg(x506,x514) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    None
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x540 = RegRead(x506) {0}
      - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
      - Scope: x544 (scope: 0, 0)
  [Ofs: 0] x536 = RegRead(x506) {}
      - Lab2GEMM.scala:37:17: Foreach(K by tileK){kk =>
      - Scope: x809 (scope: -1, -1)
  [Ofs: 0] x562 = RegRead(x506) {0,0,0}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: x583 (scope: 0, 0)))
  Result: Merged 3 into instance 0
Group #1: 
    x527 <-> x515: LCA: Host, coarse-dist: <None>
    x515 <-> x515: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x527 = RegRead(x506) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for K (x506)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x527 = RegRead(x506) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x515 = SetReg(x506,x514) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x527 = RegRead(x506) {}
      - Lab2GEMM.scala:24:21: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host))
  Attempting to merge group #1 with instance #0: 
    Computing overlaps: x527 = Some(RegRead(x506)) - x536 = Some(RegRead(x506))
    Computing overlaps: x527 = Some(RegRead(x506)) - x540 = Some(RegRead(x506))
    Computing overlaps: x527 = Some(RegRead(x506)) - x562 = Some(RegRead(x506))
    Computing overlaps: x515 = Some(SetReg(x506,x514)) - x515 = Some(SetReg(x506,x514))
      x527 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x536 <-> x515: LCA: Host, coarse-dist: <None>
      x527 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x536 <-> x515: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x540 = RegRead(x506) rd{0}
   c  modrd -> x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Dephasing Iters: x562 = RegRead(x506) rd{0,0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: ListBuffer(b50, b57, b473)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    General read dephasing rules for x506: (b50,List(0)) -> (b50,0)
  - (b50,List(0, 0, 0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b473,List(0, 0, 0)) -> (b473,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x527 = RegRead(x506) rd{}
   c  modrd, x536 = RegRead(x506) rd{}
   c  modrd, x540 = RegRead(x506) rd{0}
   c  modrd, x562 = RegRead(x506) rd{0,0,0}
   c  modrd), Set(x527 = RegRead(x506) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for K (x506)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 5 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 4 | 1 |
            - Duplicate costs 0.9013145891548795 (LUTs: 0.011695906432748537%, FFs: 7.297938332421091E-4%, BRAMs: 0.8888888888888888%)
    ***** Cost summary *****
    Cost: 0.9013145891548795 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 1: x527 = RegRead(x506) rd{}
        grp 1:    c  modrd
        grp 2: x536 = RegRead(x506) rd{}
        grp 2:    c  modrd
        grp 2: x540 = RegRead(x506) rd{0}
        grp 2:    c  modrd
        grp 2: x562 = RegRead(x506) rd{0,0,0}
        grp 2:    c  modrd
      Writes:
        grp 0: x515 = SetReg(x506,x514) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x540 = RegRead(x506) {0}
      - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
      - Scope: x544 (scope: 0, 0)
  [Ofs: 0] x536 = RegRead(x506) {}
      - Lab2GEMM.scala:37:17: Foreach(K by tileK){kk =>
      - Scope: x809 (scope: -1, -1)
  [Ofs: 0] x562 = RegRead(x506) {0,0,0}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: x583 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x527 = RegRead(x506) {}
      - Lab2GEMM.scala:24:21: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host))
  Result: Merged 1 into instance 0
Group #0: 
    x525 <-> x515: LCA: Host, coarse-dist: <None>
    x515 <-> x515: LCA: Host, coarse-dist: <None>
  solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x525 = RegRead(x506) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
  Host
  **************************************************************************************
  Analyzing costs for banking schemes found for K (x506)
  Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
    - 1 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
            Access Hist:
            | width | R | W |
            | 1 | 1 | 1 |
          - Duplicate costs 0.22532864728871987 (LUTs: 0.0029239766081871343%, FFs: 1.8244845831052726E-4%, BRAMs: 0.2222222222222222%)
  ***** Cost summary *****
  Cost: 0.22532864728871987 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
  **************************************************************************************
    Reads:
      grp 0: x525 = RegRead(x506) rd{}
      grp 0:    c  modrd
    Writes:
      grp 0: x515 = SetReg(x506,x514) wr{}
      grp 0:    c  modwr
    Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x525 = RegRead(x506) {}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host))
  Attempting to merge group #0 with instance #0: 
    Computing overlaps: x525 = Some(RegRead(x506)) - x527 = Some(RegRead(x506))
    Computing overlaps: x525 = Some(RegRead(x506)) - x536 = Some(RegRead(x506))
    Computing overlaps: x525 = Some(RegRead(x506)) - x540 = Some(RegRead(x506))
    Computing overlaps: x525 = Some(RegRead(x506)) - x562 = Some(RegRead(x506))
    Computing overlaps: x525 = Some(RegRead(x506)) - x527 = Some(RegRead(x506))
    Computing overlaps: x515 = Some(SetReg(x506,x514)) - x515 = Some(SetReg(x506,x514))
      x527 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x525 <-> x515: LCA: Host, coarse-dist: <None>
      x536 <-> x515: LCA: Host, coarse-dist: <None>
      x527 <-> x515: LCA: Host, coarse-dist: <None>
      x515 <-> x515: LCA: Host, coarse-dist: <None>
      x562 <-> x515: LCA: Host, coarse-dist: <None>
      x540 <-> x515: LCA: Host, coarse-dist: <None>
      x525 <-> x515: LCA: Host, coarse-dist: <None>
      x536 <-> x515: LCA: Host, coarse-dist: <None>
    Dephasing Iters: x562 = RegRead(x506) rd{0,0,0}
   c  modrd -> x583
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: ListBuffer(b50, b57, b473)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    Leaf: x583, Iters: ListBuffer(b50, b57, b473), target: x809, elements: List(0, 0, 0)
    Dephasing Iters: x540 = RegRead(x506) rd{0}
   c  modrd -> x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: ListBuffer(b50)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    Leaf: x544, Iters: ListBuffer(b50), target: x809, elements: List(0)
    Current: x544
    General read dephasing rules for x506: (b50,List(0)) -> (b50,0)
  - (b57,List(0, 0, 0)) -> (b57,0)
  - (b50,List(0, 0, 0)) -> (b50,0)
  - (b473,List(0, 0, 0)) -> (b473,0)
    solution bankings are Map(BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) -> Map(Set(Set(), Set(x562 = RegRead(x506) rd{0,0,0}
   c  modrd, x536 = RegRead(x506) rd{}
   c  modrd, x525 = RegRead(x506) rd{}
   c  modrd, x527 = RegRead(x506) rd{}
   c  modrd, x540 = RegRead(x506) rd{0}
   c  modrd), Set(x527 = RegRead(x506) rd{}
   c  modrd, x525 = RegRead(x506) rd{}
   c  modrd)) -> List(List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))))
    Host
    **************************************************************************************
    Analyzing costs for banking schemes found for K (x506)
    Scheme BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List())) option 0 instance 0:
      - 7 readers connect to duplicate #0 (List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)))
              Access Hist:
              | width | R | W |
              | 1 | 5 | 1 |
            - Duplicate costs 1.1266432364435994 (LUTs: 0.014619883040935672%, FFs: 9.122422915526364E-4%, BRAMs: 1.1111111111111112%)
    ***** Cost summary *****
    Cost: 1.1266432364435994 for version 0 of BankingOptions(Hierarchical(0,None),NRelaxed,AlphaRelaxed,RegroupDims(List()))
    **************************************************************************************
      Reads:
        grp 1: x525 = RegRead(x506) rd{}
        grp 1:    c  modrd
        grp 2: x527 = RegRead(x506) rd{}
        grp 2:    c  modrd
        grp 2: x536 = RegRead(x506) rd{}
        grp 2:    c  modrd
        grp 2: x540 = RegRead(x506) rd{0}
        grp 2:    c  modrd
        grp 2: x562 = RegRead(x506) rd{0,0,0}
        grp 2:    c  modrd
        grp 3: x527 = RegRead(x506) rd{}
        grp 3:    c  modrd
      Writes:
        grp 0: x515 = SetReg(x506,x514) wr{}
        grp 0:    c  modwr
      Result: Right(List(<Banked>
Depth:    1
Padding:  List()
Accum:    Buffer
Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x515 = SetReg(x506,x514) {}
      - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
      - Scope: Host
0 [Type:RD]:
 - Mux Port #0: 
  [Ofs: 0] x540 = RegRead(x506) {0}
      - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
      - Scope: x544 (scope: 0, 0)
  [Ofs: 0] x536 = RegRead(x506) {}
      - Lab2GEMM.scala:37:17: Foreach(K by tileK){kk =>
      - Scope: x809 (scope: -1, -1)
  [Ofs: 0] x562 = RegRead(x506) {0,0,0}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: x583 (scope: 0, 0)
 - Mux Port #1: 
  [Ofs: 0] x525 = RegRead(x506) {}
      - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
      - Scope: Host
  [Ofs: 0] x527 = RegRead(x506) {}
      - Lab2GEMM.scala:24:21: val b = DRAM[T](K, N) // input matrix 2
      - Scope: Host))
  Result: Merged 0 into instance 0
---------------------------------------------------------------------
SUMMARY: 
Name: K (x506)
Type: Reg[Fix[TRUE,_32,_0]]
Src:  Lab2GEMM.scala:14:18
Src:      val K = ArgIn[Int]
Symbol:     x506 = ArgInNew(Const(0))
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List()
  Accum:    Buffer
  Banking:  List(Dims {}: Cyclic: N=1, B=1, alpha=<>, P=<> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x515 = SetReg(x506,x514) {}
        - Lab2GEMM.scala:17:11: setArg(K,args(2).to[Int])
        - Scope: Host
  0 [Type:RD]:
   - Mux Port #0: 
    [Ofs: 0] x540 = RegRead(x506) {0}
        - Lab2GEMM.scala:38:46: val numel_k = min(tileK.to[Int], K - kk)
        - Scope: x544 (scope: 0, 0)
    [Ofs: 0] x536 = RegRead(x506) {}
        - Lab2GEMM.scala:37:17: Foreach(K by tileK){kk =>
        - Scope: x809 (scope: -1, -1)
    [Ofs: 0] x562 = RegRead(x506) {0,0,0}
        - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
        - Scope: x583 (scope: 0, 0)
   - Mux Port #1: 
    [Ofs: 0] x525 = RegRead(x506) {}
        - Lab2GEMM.scala:23:24: val a = DRAM[T](M, K) // input matrix 1
        - Scope: Host
    [Ofs: 0] x527 = RegRead(x506) {}
        - Lab2GEMM.scala:24:21: val b = DRAM[T](K, N) // input matrix 2
        - Scope: Host



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(2)) to x562 {0,0,0}
  Added dispatch 0 to x562 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x536 {}
  Added dispatch 0 to x536 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x525 {}
  Added dispatch 0 to x525 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x527 {}
  Added dispatch 0 to x527 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x540 {0}
  Added dispatch 0 to x540 {0}
  Added port Port(Some(0),1,0,List(0),List(1)) to x527 {}
  Added dispatch 0 to x527 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x525 {}
  Added dispatch 0 to x525 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x515 {}
  Added dispatch 0 to x515 {}
  Added port Port(Some(0),0,0,List(0),List(2)) to x562 {0,0,0}
  Added dispatch 0 to x562 {0,0,0}
  Added port Port(Some(0),0,0,List(0),List(1)) to x536 {}
  Added dispatch 0 to x536 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x525 {}
  Added dispatch 0 to x525 {}
  Added port Port(Some(0),1,0,List(0),List(1)) to x527 {}
  Added dispatch 0 to x527 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x540 {0}
  Added dispatch 0 to x540 {0}
  Added port Port(Some(0),1,0,List(0),List(1)) to x527 {}
  Added dispatch 0 to x527 {}
  Added port Port(Some(0),1,0,List(0),List(0)) to x525 {}
  Added dispatch 0 to x525 {}
  Added port Port(Some(0),0,0,List(0),List(0)) to x515 {}
  Added dispatch 0 to x515 {}
---------------------------------------------------------------------
INFERRING...
Name: x624
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x624 = StreamOutNew(BurstCmdBus)
Effort:    1
BankingViews:   List(Flat(1))
NStrictness:   List(NBestGuess, NRelaxed)
AlphaStrictness:   List(AlphaBestGuess, AlphaRelaxed)
DimensionDuplication: List(RegroupDims(List()))
Explicit Banking: None
Force Explicit Banking: false
---------------------------------------------------------------------
  Grouping 0 Reads: 

  <No Read Groups>
  Grouping 1 Writes: 
    Access: x648 {0} [x651 (stage: -1)]
  1 Write Groups:
  Group #0
    x648 = StreamOutWrite(x624,x646,Set(x647)) wr{0}
     b482     c   mod
        1     0     0wr
  x648 <-> x648: LCA: x651 (stage: -1), coarse-dist: <None>
Dephasing Iters: x648 = StreamOutWrite(x624,x646,Set(x647)) wr{0}
 b482     c   mod
    1     0     0wr -> x651
Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: ListBuffer(b482)
Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
Leaf: x651, Iters: ListBuffer(b482), target: x651, elements: List(0)
General write dephasing rules for x624: (b482,List(0)) -> (b482,0)
solution bankings are Map(BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) -> Map(Set(Set()) -> List(List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))))
x651: OpForeach (-1) [Level: InnerControl, Loop: Looped, Schedule: Sequenced]
  x648: StreamOutWrite
**************************************************************************************
Analyzing costs for banking schemes found for x624
Scheme BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List())) option 0 instance 0:
  - 0 readers connect to duplicate #0 (List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)))
          Access Hist:
          | width | R | W |
          | 1 | 0 | 1 |
        - Duplicate costs 0.0 (LUTs: 0.0%, FFs: 0.0%, BRAMs: 0.0%)
***** Cost summary *****
Cost: 0.0 for version 0 of BankingOptions(Flat(1),NBestGuess,AlphaBestGuess,RegroupDims(List()))
**************************************************************************************
  Reads:
  Writes:
    grp 0: x648 = StreamOutWrite(x624,x646,Set(x647)) wr{0}
    grp 0:  b482     c   mod
    grp 0:     1     0     0wr
  Result: Right(List(<Banked>
Depth:    1
Padding:  List(0)
Accum:    None
Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
Pipeline: ---
Ports:
0 [Type:WR]:
 - Mux Port #0: 
  [Ofs: 0] x648 = StreamOutWrite(x624,x646,Set(x647)) {0}
      - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
      - Scope: x651 (scope: 0, 0)
0 [Type:RD]:))
---------------------------------------------------------------------
SUMMARY: 
Name: x624
Type: StreamOut[BurstCmd]
Src:  Lab2GEMM.scala:47:32
Src:                      tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
Symbol:     x624 = StreamOutNew(BurstCmdBus)
---------------------------------------------------------------------
Instances: 1
Instance #0
  <Banked>
  Depth:    1
  Padding:  List(0)
  Accum:    None
  Banking:  List(Dims {0}: Cyclic: N=1, B=1, alpha=<1>, P=<1> (1 solutions, 0 checks)) <Flat>
  Pipeline: ---
  Ports:
  0 [Type:WR]:
   - Mux Port #0: 
    [Ofs: 0] x648 = StreamOutWrite(x624,x646,Set(x647)) {0}
        - Lab2GEMM.scala:47:32: tileB_sram load b(kk::kk+numel_k, nn::nn+numel_n) // DRAM -> SRAM
        - Scope: x651 (scope: 0, 0)
  0 [Type:RD]:



---------------------------------------------------------------------




  Added port Port(Some(0),0,0,List(0),List(0)) to x648 {0}
  Added dispatch 0 to x648 {0}
  Added port Port(Some(0),0,0,List(0),List(0)) to x648 {0}
  Added dispatch 0 to x648 {0}
x758 completed in: 0 ms
x557 completed in: 0 ms
x624 completed in: 0 ms
x655 completed in: 1 ms
x761 completed in: 1 ms
x714 completed in: 1 ms
x757 completed in: 1 ms
x682 completed in: 1 ms
x657 completed in: 1 ms
x558 completed in: 1 ms
x713 completed in: 1 ms
x681 completed in: 1 ms
x626 completed in: 1 ms
x589 completed in: 1 ms
x712 completed in: 1 ms
x656 completed in: 1 ms
x556 completed in: 1 ms
x588 completed in: 1 ms
x763 completed in: 1 ms
x587 completed in: 2 ms
x756 completed in: 2 ms
x621 completed in: 3 ms
x625 completed in: 4 ms
x539 completed in: 6 ms
x683 completed in: 8 ms
x506 completed in: 11 ms
x548 completed in: 12 ms
x504 completed in: 14 ms
x622 completed in: 14 ms
x554 completed in: 16 ms
x505 completed in: 16 ms
x615 completed in: 20 ms
x762 completed in: 39 ms
